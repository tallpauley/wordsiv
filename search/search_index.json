{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>WordSiv is a Python library for generating proofing text for an incomplete typeface. </p> <p> </p> <p>Documentation: https://wordsiv.com</p> <p>Source Code: https://github.com/tallpauley/wordsiv</p> <p>Say you've drawn <code>HAMBUGERFONTSIVhambugerfontsiv.,</code> and want a sentence with only those glyphs: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERFONTSIVhambugerfontsiv.,\")\nprint(wsv.sent(rnd=0.03))  # rnd lets us turn up the randomness\n</code></pre></p> <p>This returns something like:</p> <p>Bears run saint that fighting bargain remove, genre MA Barbara registration the bug it others entering Steven.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Shaped Text: WordSiv generates text that is roughly the shape of text in   the desired language using word/punctuation probabilities and capitalization.</li> <li>Easy Word Filtering: WordSiv selects from words that can be spelled with   your current glyph set, so you don't have to worry about <code>.notdef</code>. Add   additional word requirements (substrings, patterns, word length, etc.) on top   without having to wrangle regex.</li> <li>Letter Case Aware: WordSiv has a simple <code>case</code> argument to set the desired   case of words, and choose whether to transform letter case of the words in the   Vocab. Words like <code>\"I\", \"Paris\", \"DDoS\", \"WWF\"</code> will by appear in their   original letter case by default (if the Vocab has capitalization).</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#installing-in-drawbot","title":"Installing in DrawBot","text":"<ol> <li> <p>In the DrawBot menu, click Python-&gt;Install Python Packages:</p> </li> <li> <p>Enter <code>git+https://github.com/tallpauley/wordsiv</code> and click Go!</p> </li> </ol> <p></p>"},{"location":"#updating-wordsiv-in-drawbot","title":"Updating WordSiv in DrawBot","text":"<p>DrawBot caches Python packages/modules, so I'd recommend this process for updating to the latest version of WordSiv:</p> <ol> <li>In the DrawBot menu, click Python-&gt;Install Python Packages.<ul> <li>Click the dropdown Install / Upgrade and select Uninstall.</li> <li>Enter <code>wordsiv</code> and click Go!.</li> </ul> </li> <li>Restart DrawBot.</li> <li>Follow the above instructions to install the latest    version of WordSiv.</li> </ol>"},{"location":"#installing-outside-of-drawbot","title":"Installing Outside of DrawBot","text":"<p>You can also install WordSiv on your system and use it in any Python script. You'll probably want to use a virtual environment or a Python tool that manages these for you, but I'll leave that up to you!</p> <p>First, make sure you have Python 3.9+. Then:</p> <pre><code>pip install git+https://github.com/tallpauley/wordsiv\n</code></pre>"},{"location":"#why-simple-word-probability","title":"Why Simple Word Probability?","text":"<p>Proofing text doesn't necessarily have to be syntactically correct or have meaning. It just needs the right amount of common and uncommon words to give it a \"realistic\" shape. Often, type designers do this manually, such as in Jonathan Hoefler's fantastic proof:</p> <p>Finally, I wanted the text to have the visual cadences of my native English, in which words of variable but digestible length are punctuated by shorter ones.</p> <p>If we simply select words randomly, out of a hat which contains many more duplicates of, say, \"the\" than \"etymology\", we'll get a string of words which visually resembles a sentence. This is how WordSiv works: sampling words from a probability distribution which is determined by the occurrence counts of words in a corpus of text.</p> <p>Of course, the more we restrict our glyph set, the more we've tampered with the natural distribution of words, since most of the longer, less-common words aren't available (which make up the long tail of the Zipf Distribution). However, we can blend in a bit of randomness to make it look like real text at a glance!</p> <p>This might be more fun with LLMs, because the glyph-limited text could potentially be both grammatically and semantically correct. However, it remains to be seen if stability can be achieved while filtering out the majority of tokens. And more importantly, why spend so much more compute for so little payoff?</p>"},{"location":"#related-resources","title":"Related Resources","text":""},{"location":"#software-tools-comparison","title":"Software Tools Comparison","text":"Revocab Type Author Glyphs Filtering Algorithm Probability WordSiv CLI Chris Pauley Yes word probability (for now) Yes Galvanized Jets web tool Samarskaya &amp; Partners No static text N/A Adhesion Text web tool Miguel Sousa Yes random word No Word-o-mat Plugin Nina St\u00f6ssinger No random word No Test Text Generator web tool, CLI Tim Ahrens Yes trigram character prediction Yes"},{"location":"#other-resources","title":"Other Resources","text":"Revocab Author Notes Proof a Typeface Jonathan Hoefler A concise and comprehensive proof of illustrative English words, covering all round/flat spacing trigrams, including bigrams for sentence start/end and 4-grams for repeated letters. Made to look more text-like with joining phrases like \"of the\". LLM Lipogram Guide Corey Hanson A really cool example of using LLMs for lipograms. AI Writing Assistant Allen Roush, Sanjay Basu, Akshay Moorthy, Dmitry Dubovoy Another example of filtering the output of an LLM for lipogram generation and more."},{"location":"api-reference/","title":"API Reference","text":"<p>WordSiv is a Python library for generating text for an incomplete typeface.</p> <p>Classes:</p> Name Description <code>Vocab</code> <p>A vocabulary of words and occurrence counts with metadata for filtering and punctuating.</p> <code>WordSiv</code> <p>The main WordSiv object which uses Vocabs to generate text.</p> <p>Attributes:</p> Name Type Description <code>CaseType</code> <p>Options for setting case via the <code>case</code> argument.</p>"},{"location":"api-reference/#wordsiv.CaseType","title":"CaseType  <code>module-attribute</code>","text":"<pre><code>CaseType = Literal[\n    \"any\",\n    \"any_og\",\n    \"lc\",\n    \"lc_force\",\n    \"cap\",\n    \"cap_og\",\n    \"cap_force\",\n    \"uc\",\n    \"uc_og\",\n    \"uc_force\",\n]\n</code></pre> <p>Options for setting case via the <code>case</code> argument. See Letter Case in the Guide for detailed descriptions and examples of each option</p>"},{"location":"api-reference/#wordsiv.Vocab","title":"Vocab","text":"<p>A vocabulary of words and occurrence counts with metadata for filtering and punctuating.</p> <p>Attributes:</p> Name Type Description <code>lang</code> <code>str</code> <p>The language of the vocabulary.</p> <code>bicameral</code> <code>bool</code> <p>Specifies whether the vocabulary has uppercase and lowercase letters.</p> <code>punctuation</code> <code>dict</code> <p>A dictionary or None for handling punctuation in generated text.</p> <code>data</code> <code>str</code> <p>A TSV-formatted string with word-count pairs or a newline-delimited list of words.</p> <code>data_file</code> <code>str | Traversable</code> <p>A path to a file to supply the data instead of the data attribute.</p> <code>meta</code> <code>dict</code> <p>Additional metadata for the vocabulary.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Vocab instance.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Returns raw data from parameter _data or data_file.</p> <code>wordcount</code> <code>tuple[tuple[str, int], ...]</code> <p>Returns a tuple of tuples with words and counts.</p> <code>wordcount_str</code> <code>str</code> <p>Returns a TSV-formatted string with words and counts.</p> Source code in <code>wordsiv/_vocab.py</code> <pre><code>class Vocab:\n    \"\"\"A vocabulary of words and occurrence counts with metadata for filtering and punctuating.\n\n    Attributes:\n        lang (str): The language of the vocabulary.\n        bicameral (bool): Specifies whether the vocabulary has uppercase and lowercase letters.\n        punctuation (dict, optional): A dictionary or None for handling punctuation in generated text.\n        data (str, optional): A TSV-formatted string with word-count pairs or a newline-delimited list of words.\n        data_file (str | Traversable, optional): A path to a file to supply the data instead of the data attribute.\n        meta (dict, optional): Additional metadata for the vocabulary.\n    \"\"\"\n\n    def __init__(\n        self,\n        lang: str,\n        bicameral: bool,\n        punctuation: dict | None = None,\n        data: str | None = None,\n        data_file: str | Traversable | None = None,\n        meta: dict | None = None,\n    ):\n        \"\"\"Initializes the Vocab instance.\n\n        Args:\n            lang (str): The language of the vocabulary.\n            bicameral (bool): Specifies whether the vocabulary has uppercase and lowercase letters.\n            punctuation (dict, optional): A dictionary or None for handling punctuation in generated text.\n            data (str, optional): A TSV-formatted string with word-count pairs or a newline-delimited list of words.\n            data_file (str | Traversable, optional): A path to a file to supply the data instead of the data attribute.\n            meta (dict, optional): Additional metadata for the vocabulary.\n        \"\"\"\n\n        self.lang = lang\n        self.bicameral = bicameral\n        self.punctuation = punctuation\n        self._data = data\n        self.data_file = data_file\n        self.meta = meta\n\n        if data and data_file:\n            raise ValueError(\"Cannot specify both 'data' and 'data_file'\")\n        elif data is None and not data_file:\n            raise ValueError(\"Must specify either 'data' or 'data_file'\")\n\n    @property\n    def data(self):\n        \"\"\"Returns raw data from parameter _data or data_file.\"\"\"\n\n        if self._data is not None:\n            data = self._data\n        elif getattr(self, \"data_file\", None):\n            data = _read_file(self.data_file)\n        if not data:\n            raise VocabEmptyError(f\"No data found in {self.data_file}\")\n\n        return data\n\n    @property\n    def wordcount_str(self) -&gt; str:\n        \"\"\"Returns a TSV-formatted string with words and counts.\"\"\"\n\n        firstline = self.data.partition(\"\\n\")[0]\n\n        if regex.match(r\"[[:alpha:]]+\\t\\d+$\", firstline):\n            # if we have counts, return the original string\n            return self.data\n        elif regex.match(r\"[[:alpha:]]+$\", firstline):\n            # if we just have newline-delimited words, add counts of 1\n            return _add_counts_to_wordcount_str(self.data)\n        else:\n            raise VocabFormatError(\n                \"The vocab file is formatted incorrectly. \"\n                \"Should be a TSV file with words and counts as columns, or a newline-delimited list of words.\"\n            )\n\n    @property\n    def wordcount(self) -&gt; tuple[tuple[str, int], ...]:\n        \"\"\"Returns a tuple of tuples with words and counts.\"\"\"\n\n        return _wordcount_str_to_wordcount_tuple(self.wordcount_str)\n\n    def filter(self, **kwargs):\n        return _filter_wordcount(self.wordcount_str, self.bicameral, **kwargs)\n</code></pre>"},{"location":"api-reference/#wordsiv.Vocab.data","title":"data  <code>property</code>","text":"<pre><code>data\n</code></pre> <p>Returns raw data from parameter _data or data_file.</p>"},{"location":"api-reference/#wordsiv.Vocab.wordcount","title":"wordcount  <code>property</code>","text":"<pre><code>wordcount\n</code></pre> <p>Returns a tuple of tuples with words and counts.</p>"},{"location":"api-reference/#wordsiv.Vocab.wordcount_str","title":"wordcount_str  <code>property</code>","text":"<pre><code>wordcount_str\n</code></pre> <p>Returns a TSV-formatted string with words and counts.</p>"},{"location":"api-reference/#wordsiv.Vocab.__init__","title":"__init__","text":"<pre><code>__init__(\n    lang,\n    bicameral,\n    punctuation=None,\n    data=None,\n    data_file=None,\n    meta=None,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>The language of the vocabulary.</p> required <code>bicameral</code> <code>bool</code> <p>Specifies whether the vocabulary has uppercase and lowercase letters.</p> required <code>punctuation</code> <code>dict</code> <p>A dictionary or None for handling punctuation in generated text.</p> <code>None</code> <code>data</code> <code>str</code> <p>A TSV-formatted string with word-count pairs or a newline-delimited list of words.</p> <code>None</code> <code>data_file</code> <code>str | Traversable</code> <p>A path to a file to supply the data instead of the data attribute.</p> <code>None</code> <code>meta</code> <code>dict</code> <p>Additional metadata for the vocabulary.</p> <code>None</code> Source code in <code>wordsiv/_vocab.py</code> <pre><code>def __init__(\n    self,\n    lang: str,\n    bicameral: bool,\n    punctuation: dict | None = None,\n    data: str | None = None,\n    data_file: str | Traversable | None = None,\n    meta: dict | None = None,\n):\n    \"\"\"Initializes the Vocab instance.\n\n    Args:\n        lang (str): The language of the vocabulary.\n        bicameral (bool): Specifies whether the vocabulary has uppercase and lowercase letters.\n        punctuation (dict, optional): A dictionary or None for handling punctuation in generated text.\n        data (str, optional): A TSV-formatted string with word-count pairs or a newline-delimited list of words.\n        data_file (str | Traversable, optional): A path to a file to supply the data instead of the data attribute.\n        meta (dict, optional): Additional metadata for the vocabulary.\n    \"\"\"\n\n    self.lang = lang\n    self.bicameral = bicameral\n    self.punctuation = punctuation\n    self._data = data\n    self.data_file = data_file\n    self.meta = meta\n\n    if data and data_file:\n        raise ValueError(\"Cannot specify both 'data' and 'data_file'\")\n    elif data is None and not data_file:\n        raise ValueError(\"Must specify either 'data' or 'data_file'\")\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv","title":"WordSiv","text":"<p>The main WordSiv object which uses Vocabs to generate text.</p> <p>This object serves as the main interface for generating text. It can hold multiple vocabulary objects, store default settings (like default glyphs and vocab), and expose high-level methods that produce words, sentences, paragraphs, and more.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str | None</code> <p>The name of the default Vocab.</p> <code>None</code> <code>glyphs</code> <code>str | None</code> <p>The default set of glyphs that constrains the words generated.</p> <code>None</code> <code>add_default_vocabs</code> <code>bool</code> <p>Whether to add the default Vocabs defined in <code>DEFAULT_VOCABS</code>.</p> <code>True</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors or fail gently.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>vocab</code> <code>str | None</code> <p>The name of the default Vocab.</p> <code>glyphs</code> <code>str | None</code> <p>The default set of glyphs that constrains the words generated.</p> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors or fail gently.</p> <code>_vocab_lookup</code> <code>dict[str, Vocab]</code> <p>A dictionary of vocab names to <code>Vocab</code> objects.</p> <code>_rand</code> <code>Random</code> <p>A <code>random.Random</code> instance.</p> <p>Methods:</p> Name Description <code>add_vocab</code> <p>Add a <code>Vocab</code> object to this <code>WordSiv</code> instance under a given name.</p> <code>get_vocab</code> <p>Retrieve a <code>Vocab</code> by name, or return the default Vocab if <code>vocab_name</code> is None.</p> <code>list_vocabs</code> <p>Return a list of all available Vocab names.</p> <code>number</code> <p>Generate a random numeric string (made of digits) constrained by glyphs and</p> <code>para</code> <p>Generate a paragraph by creating multiple sentences with <code>sents(...)</code> and</p> <code>paras</code> <p>Generate multiple paragraphs with <code>para(...)</code>, returned as a list.</p> <code>seed</code> <p>Seed the random number generator for reproducible results.</p> <code>sent</code> <p>Generate a single sentence, optionally punctuated, using words (and/or numbers).</p> <code>sents</code> <p>Generate multiple sentences with <code>sent(...)</code>, returned as a list.</p> <code>text</code> <p>Generate multiple paragraphs of text, calling <code>paras(...)</code> and joining them with</p> <code>top_word</code> <p>Retrieve the most common (or nth most common) word from the Vocab, subject to</p> <code>top_words</code> <p>Retrieve the top <code>n_words</code> from the Vocab, starting at index <code>idx</code>, subject to</p> <code>word</code> <p>Generate a random word that meets a variety of constraints, such as glyphs,</p> <code>words</code> <p>Generate a list of words (and optionally numbers) according to the specified</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>class WordSiv:\n    \"\"\"The main WordSiv object which uses Vocabs to generate text.\n\n    This object serves as the main interface for generating text. It can hold multiple\n    vocabulary objects, store default settings (like default glyphs and vocab), and\n    expose high-level methods that produce words, sentences, paragraphs, and more.\n\n    Args:\n        vocab (str | None): The name of the default Vocab.\n        glyphs (str | None): The default set of glyphs that constrains the words\n            generated.\n        add_default_vocabs (bool): Whether to add the default Vocabs defined in\n            `DEFAULT_VOCABS`.\n        raise_errors (bool): Whether to raise errors or fail gently.\n        seed (int | None): Seed for the random number generator.\n\n    Attributes:\n        vocab (str | None): The name of the default Vocab.\n        glyphs (str | None): The default set of glyphs that constrains the words\n            generated.\n        raise_errors (bool): Whether to raise errors or fail gently.\n        _vocab_lookup (dict[str, Vocab]): A dictionary of vocab names to `Vocab`\n            objects.\n        _rand (random.Random): A `random.Random` instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        vocab: str | None = None,\n        glyphs: str | None = None,\n        add_default_vocabs: bool = True,\n        raise_errors: bool = False,\n        seed=None,\n    ):\n        self.vocab = vocab\n        self.glyphs = glyphs\n        self.raise_errors = raise_errors\n        self._vocab_lookup: dict[str, Vocab] = {}\n\n        if add_default_vocabs:\n            self._add_default_vocabs()\n\n        self._rand = random.Random()\n\n        if seed is not None:\n            self.seed(seed)\n\n    def seed(self, seed: float | str | None = None) -&gt; None:\n        \"\"\"\n        Seed the random number generator for reproducible results.\n\n        Args:\n            seed (float | str | None): The seed value used to initialize the random\n                number generator.\n\n        Returns:\n            None\n        \"\"\"\n        self._rand.seed(seed)\n\n    def add_vocab(self, vocab_name: str, vocab: Vocab) -&gt; None:\n        \"\"\"\n        Add a `Vocab` object to this `WordSiv` instance under a given name.\n\n        Args:\n            vocab_name (str): The unique identifier for this Vocab.\n            vocab (Vocab): The `Vocab` object to be associated with `vocab_name`.\n\n        Returns:\n            None\n        \"\"\"\n        self._vocab_lookup[vocab_name] = vocab\n\n    def _add_default_vocabs(self) -&gt; None:\n        \"\"\"\n        Initialize and add the default Vocabs to this `WordSiv` instance.\n\n        The default vocabularies are specified in the `DEFAULT_VOCABS` dictionary, which\n        maps a short code (e.g., 'en', 'es') to the meta and data filenames. This method\n        initializes each Vocab (however, the data is loaded lazily).\n        \"\"\"\n        for vocab_name, (meta_file, data_file) in _DEFAULT_VOCABS.items():\n            meta_path = resources.files(_vocab_data) / meta_file\n            with meta_path.open(\"r\", encoding=\"utf8\") as f:\n                meta = json.load(f)\n\n            data_path = resources.files(_vocab_data) / data_file\n            vocab = Vocab(\n                meta[\"lang\"], bool(meta[\"bicameral\"]), meta=meta, data_file=data_path\n            )\n            self.add_vocab(vocab_name, vocab)\n\n    def get_vocab(self, vocab_name: str | None = None) -&gt; Vocab:\n        \"\"\"\n        Retrieve a `Vocab` by name, or return the default Vocab if `vocab_name` is None.\n\n        Args:\n            vocab_name (str | None): The name of the Vocab to retrieve. If None,\n                use the default `self.vocab`.\n\n        Returns:\n            Vocab: The `Vocab` object corresponding to `vocab_name`.\n\n        Raises:\n            ValueError: If no `vocab_name` is provided and no default is set.\n        \"\"\"\n        if vocab_name:\n            return self._vocab_lookup[vocab_name]\n        else:\n            if self.vocab:\n                return self._vocab_lookup[self.vocab]\n            else:\n                raise ValueError(\"Error: no vocab specified\")\n\n    def list_vocabs(self) -&gt; list[str]:\n        \"\"\"\n        Return a list of all available Vocab names.\n\n        Returns:\n            list[str]: A list of all registered Vocab names in this `WordSiv`.\n        \"\"\"\n        return list(self._vocab_lookup.keys())\n\n    def number(\n        self,\n        seed: float | str | None = None,\n        glyphs: str | None = None,\n        wl: int | None = None,\n        min_wl: int = 1,\n        max_wl: int = _DEFAULT_MAX_NUM_LENGTH,\n        raise_errors: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Generate a random numeric string (made of digits) constrained by glyphs and\n        other parameters.\n\n        Args:\n            seed (float | str | None): Seed the random number generator if seed is not\n                None.\n            glyphs (str | None): A string of allowed glyphs. If None, uses the default\n                glyphs of this `WordSiv` instance.\n            wl (int | None): Exact length of the generated numeric string. If None, a\n                random length between `min_wl` and `max_wl` is chosen.\n            min_wl (int): Minimum length of the numeric string. Defaults to 1.\n            max_wl (int): Maximum length of the numeric string. Defaults to 4.\n            raise_errors (bool): Whether to raise an error if no numerals are available.\n\n        Returns:\n            str: A randomly generated string consisting of numerals.\n\n        Raises:\n            ValueError: If `min_wl` is greater than `max_wl`.\n            FilterError: If no numerals are available in `glyphs` and `raise_errors` is\n                True.\n        \"\"\"\n        glyphs = self.glyphs if glyphs is None else glyphs\n        raise_errors = self.raise_errors if raise_errors is None else raise_errors\n\n        if seed is not None:\n            self._rand.seed(seed)\n\n        if wl:\n            length = wl\n        else:\n            if min_wl &gt; max_wl:\n                raise ValueError(\"'min_wl' must be less than or equal to 'max_wl'\")\n            length = self._rand.randint(min_wl, max_wl)\n\n        available_numerals = \"\".join(str(n) for n in range(0, 10))\n        if glyphs:\n            available_numerals = \"\".join(n for n in available_numerals if n in glyphs)\n\n            if not available_numerals:\n                if raise_errors:\n                    raise FilterError(\"No numerals available in glyphs\")\n                else:\n                    log.warning(\"No numerals available in glyphs\")\n                    return \"\"\n\n        return \"\".join(self._rand.choice(available_numerals) for _ in range(length))\n\n    def word(\n        self,\n        vocab: str | None = None,\n        glyphs: str | None = None,\n        seed: float | str | None = None,\n        rnd: float = 0,\n        case: CaseType = \"any\",\n        top_k: int = 0,\n        min_wl: int = 1,\n        max_wl: int | None = None,\n        wl: int | None = None,\n        contains: str | Sequence[str] | None = None,\n        inner: str | Sequence[str] | None = None,\n        startswith: str | None = None,\n        endswith: str | None = None,\n        regexp: str | None = None,\n        raise_errors: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Generate a random word that meets a variety of constraints, such as glyphs,\n        length, regex filters, etc.\n\n        Args:\n            vocab (str | None): Name of the Vocab to use. If None, uses default Vocab.\n            glyphs (str | None): A string of allowed glyphs. If None, uses default\n                glyphs.\n            seed (float | str | None): Seed the random number generator if seed is not\n                None.\n            rnd (float): Randomness factor in [0, 1] for selecting among the top words.\n            case (CaseType): Desired case of the output word (e.g., 'upper', 'lower',\n                'any').\n            top_k (int): If &gt; 0, only consider the top K words by frequency.\n            min_wl (int): Minimum word length.\n            max_wl (int | None): Maximum word length. If None, no maximum is applied.\n            wl (int | None): Exact word length. If None, no exact length is enforced.\n            contains (str | Sequence[str] | None): Substring(s) that must appear in the\n                word.\n            inner (str | Sequence[str] | None): Substring(s) that must appear, but not\n                at the start or end of the word.\n            startswith (str | None): Required starting substring.\n            endswith (str | None): Required ending substring.\n            regexp (str | None): A regular expression that the word must match.\n            raise_errors (bool): Whether to raise filtering errors or fail gently.\n\n        Returns:\n            str: A randomly generated word meeting the specified constraints (or an\n                empty string on failure if `raise_errors` is False).\n\n        Raises:\n            ValueError: If `rnd` is not in [0, 1].\n            FilterError: If filtering yields no results and `raise_errors` is True.\n            VocabFormatError: If the underlying Vocab data is malformed.\n            VocabEmptyError: If the underlying Vocab is empty.\n        \"\"\"\n        glyphs = self.glyphs if glyphs is None else glyphs\n        raise_errors = self.raise_errors if raise_errors is None else raise_errors\n        vocab_obj = self.get_vocab(vocab)\n\n        if not (0 &lt;= rnd &lt;= 1):\n            raise ValueError(\"'rnd' must be between 0 and 1\")\n\n        if seed is not None:\n            self._rand.seed(seed)\n\n        try:\n            wc_list = vocab_obj.filter(\n                glyphs=glyphs,\n                case=case,\n                min_wl=min_wl,\n                max_wl=max_wl,\n                wl=wl,\n                contains=contains,\n                inner=inner,\n                startswith=startswith,\n                endswith=endswith,\n                regexp=regexp,\n            )\n        except FilterError as e:\n            if raise_errors:\n                raise e\n            else:\n                log.warning(\"%s\", e.args[0])\n                return \"\"\n\n        if top_k:\n            wc_list = wc_list[:top_k]\n\n        return _sample_word(wc_list, self._rand, rnd)\n\n    def top_word(\n        self,\n        vocab: str | None = None,\n        glyphs: str | None = None,\n        seed: float | str | None = None,\n        idx: int = 0,\n        case: CaseType = \"any\",\n        min_wl: int = 2,\n        max_wl: int | None = None,\n        wl: int | None = None,\n        contains: str | Sequence[str] | None = None,\n        inner: str | Sequence[str] | None = None,\n        startswith: str | None = None,\n        endswith: str | None = None,\n        regexp: str | None = None,\n        raise_errors: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Retrieve the most common (or nth most common) word from the Vocab, subject to\n        filtering constraints.\n\n        Args:\n            vocab (str | None): Name of the Vocab to use. If None, use the default\n                Vocab.\n            glyphs (str | None): Whitelisted glyphs to filter words. If None, uses\n                default.\n            seed (float | str | None): Seed the random number generator if seed is\n                not None.\n            idx (int): Index of the desired word in the frequency-sorted list\n                (0-based).\n            case (CaseType): Desired case form for the word (e.g., 'lower', 'upper',\n                'any').\n            min_wl (int): Minimum word length.\n            max_wl (int | None): Maximum word length. If None, no maximum.\n            wl (int | None): Exact word length. If None, no exact length filter.\n            contains (str | Sequence[str] | None): Substring(s) that must appear in\n                the word.\n            inner (str | Sequence[str] | None): Substring(s) that must appear in the\n                interior.\n            startswith (str | None): Substring that the word must start with.\n            endswith (str | None): Substring that the word must end with.\n            regexp (str | None): Regex pattern that the word must match.\n            raise_errors (bool): Whether to raise errors on filter or index failures.\n\n        Returns:\n            str: The nth most common word that meets the constraints (or an empty string\n                on failure if `raise_errors` is False).\n\n        Raises:\n            FilterError: If filtering fails (no words match) and `raise_errors` is True.\n            ValueError: If no default vocab is set when `vocab` is None.\n            IndexError: If `idx` is out of range after filtering and `raise_errors` is\n                True.\n        \"\"\"\n        glyphs = self.glyphs if glyphs is None else glyphs\n        raise_errors = self.raise_errors if raise_errors is None else raise_errors\n        vocab_obj = self.get_vocab(self.vocab) if not vocab else self.get_vocab(vocab)\n\n        try:\n            wc_list = vocab_obj.filter(\n                glyphs=glyphs,\n                case=case,\n                min_wl=min_wl,\n                max_wl=max_wl,\n                wl=wl,\n                contains=contains,\n                inner=inner,\n                startswith=startswith,\n                endswith=endswith,\n                regexp=regexp,\n            )\n        except FilterError as e:\n            if raise_errors:\n                raise e\n            else:\n                log.warning(\"%s\", e.args[0])\n                return \"\"\n\n        try:\n            return wc_list[idx][0]\n        except IndexError:\n            if raise_errors:\n                raise FilterError(f\"No word at index idx='{idx}'\")\n            else:\n                log.warning(\"No word at index idx='%s'\", idx)\n                return \"\"\n\n    def words(\n        self,\n        vocab: str | None = None,\n        glyphs: str | None = None,\n        seed=None,\n        n_words: int | None = None,\n        min_n_words: int = 10,\n        max_n_words: int = 20,\n        numbers: float = 0,\n        cap_first: bool | None = None,\n        case: CaseType = \"any\",\n        rnd: float = 0,\n        min_wl: int = 1,\n        max_wl: int | None = None,\n        wl: int | None = None,\n        raise_errors: bool = False,\n        **word_kwargs,\n    ) -&gt; list[str]:\n        \"\"\"\n        Generate a list of words (and optionally numbers) according to the specified\n        parameters.\n\n        This method will produce `n_words` tokens, each of which may be a word or a\n        number (digit string), depending on the `numbers` ratio. It can also\n        automatically handle capitalization of the first token if `cap_first` is True\n        (or inferred).\n\n        Args:\n            vocab (str | None): Name of the Vocab to use. If None, uses the default\n                Vocab.\n            glyphs (str | None): Allowed glyph set. If None, uses the default glyphs.\n            seed (any): Seed for the random number generator. If None, current state is\n                used.\n            n_words (int | None): Exact number of tokens to generate. If None, randomly\n                choose between `min_n_words` and `max_n_words`.\n            min_n_words (int): Minimum number of tokens if `n_words` is not specified.\n            max_n_words (int): Maximum number of tokens if `n_words` is not specified.\n            numbers (float): A value in [0, 1] that determines the probability of\n                generating a numeric token instead of a word.\n            cap_first (bool | None): If True, capitalize the first word (if `case` is\n                \"any\"). If None, automatically decide based on glyphs availability.\n            case (CaseType): Desired case form for the words (\"any\", \"lower\", \"upper\",\n                etc.).\n            rnd (float): Randomness factor for word selection, in [0, 1].\n            min_wl (int): Minimum length for words/numbers.\n            max_wl (int): Maximum length for words/numbers.\n            wl (int | None): Exact length for words/numbers. If None, uses min/max_wl.\n            raise_errors (bool): Whether to raise errors or fail gently.\n            **word_kwargs: Additional keyword arguments passed along to `word()`.\n\n        Returns:\n            list[str]: A list of randomly generated tokens (words or numbers).\n\n        Raises:\n            ValueError: If `numbers` is not in [0, 1].\n        \"\"\"\n        glyphs = self.glyphs if glyphs is None else glyphs\n\n        if seed is not None:\n            self._rand.seed(seed)\n\n        if not n_words:\n            n_words = self._rand.randint(min_n_words, max_n_words)\n\n        if cap_first is None:\n            if glyphs:\n                # If constrained glyphs, only capitalize if uppercase letters exist\n                cap_first = any(c for c in glyphs if c.isupper())\n            else:\n                # Otherwise, default to capitalize the first word\n                cap_first = True\n\n        if not (0 &lt;= numbers &lt;= 1):\n            raise ValueError(\"'numbers' must be between 0 and 1\")\n\n        word_list = []\n        last_w = None\n        for i in range(n_words):\n            if cap_first and case == \"any\" and i == 0:\n                word_case: CaseType = \"cap\"\n            else:\n                word_case = case\n\n            token_type = self._rand.choices(\n                [\"word\", \"number\"],\n                weights=[1 - numbers, numbers],\n            )[0]\n\n            if token_type == \"word\":\n                w = self.word(\n                    vocab=vocab,\n                    glyphs=glyphs,\n                    case=word_case,\n                    rnd=rnd,\n                    min_wl=min_wl,\n                    max_wl=max_wl,\n                    wl=wl,\n                    raise_errors=raise_errors,\n                    **word_kwargs,\n                )\n\n                # Try once more to avoid consecutive repeats\n                # TODO: this is a hack, we should find a better way to avoid consecutive\n                # repeats\n                if w == last_w:\n                    w = self.word(\n                        vocab=vocab,\n                        glyphs=glyphs,\n                        case=word_case,\n                        rnd=rnd,\n                        min_wl=min_wl,\n                        max_wl=max_wl,\n                        wl=wl,\n                        raise_errors=raise_errors,\n                        **word_kwargs,\n                    )\n\n                if w:\n                    word_list.append(w)\n                    last_w = w\n            else:\n                # token_type == \"number\"\n                w = self.number(\n                    glyphs=glyphs,\n                    wl=wl,\n                    min_wl=min_wl,\n                    max_wl=max_wl or _DEFAULT_MAX_NUM_LENGTH,\n                    raise_errors=raise_errors,\n                )\n\n                if w:\n                    word_list.append(w)\n                    last_w = w\n\n        return word_list\n\n    def top_words(\n        self,\n        glyphs: str | None = None,\n        vocab: str | None = None,\n        n_words: int = 10,\n        idx: int = 0,\n        case: CaseType = \"any\",\n        min_wl: int = 1,\n        max_wl: int | None = None,\n        wl: int | None = None,\n        contains: str | Sequence[str] | None = None,\n        inner: str | Sequence[str] | None = None,\n        startswith: str | None = None,\n        endswith: str | None = None,\n        regexp: str | None = None,\n        raise_errors: bool = False,\n    ) -&gt; list[str]:\n        \"\"\"\n        Retrieve the top `n_words` from the Vocab, starting at index `idx`, subject to\n        filtering constraints.\n\n        Args:\n            glyphs (str | None): Allowed glyph set. If None, uses default glyphs.\n            vocab (str | None): Name of the Vocab to use. If None, use the default\n                Vocab.\n            n_words (int): Number of words to return.\n            idx (int): The index at which to start returning words (0-based).\n            case (CaseType): Desired case form (\"any\", \"upper\", \"lower\", etc.).\n            min_wl (int): Minimum word length. Defaults to 1.\n            max_wl (int | None): Maximum word length. If None, no maximum is applied.\n            wl (int | None): Exact word length. If None, no exact length filter.\n            contains (str | Sequence[str] | None): Substring(s) that must appear.\n            inner (str | Sequence[str] | None): Substring(s) that must appear, not at\n                edges.\n            startswith (str | None): Required starting substring.\n            endswith (str | None): Required ending substring.\n            regexp (str | None): Regex pattern(s) to match.\n            raise_errors (bool): Whether to raise errors or fail gently.\n\n        Returns:\n            list[str]: A list of up to `n_words` words, in descending frequency order.\n\n        Raises:\n            FilterError: If filtering fails (no words match) and `raise_errors` is True.\n        \"\"\"\n        glyphs = self.glyphs if glyphs is None else glyphs\n        vocab_obj = self.get_vocab(self.vocab) if not vocab else self.get_vocab(vocab)\n\n        try:\n            wc_list = vocab_obj.filter(\n                glyphs=glyphs,\n                case=case,\n                min_wl=min_wl,\n                max_wl=max_wl,\n                wl=wl,\n                contains=contains,\n                inner=inner,\n                startswith=startswith,\n                endswith=endswith,\n                regexp=regexp,\n            )[idx : idx + n_words]\n        except FilterError as e:\n            if raise_errors:\n                raise e\n            else:\n                log.warning(\"%s\", e.args[0])\n                return []\n\n        if not wc_list:\n            if raise_errors:\n                raise FilterError(f\"No words found at idx '{idx}'\")\n            else:\n                log.warning(\"No words found at idx '%s'\", idx)\n                return []\n\n        return [w for w, _ in wc_list]\n\n    def sent(\n        self,\n        vocab: str | None = None,\n        glyphs: str | None = None,\n        seed=None,\n        punc: bool = True,\n        rnd_punc: float = 0,\n        **words_kwargs,\n    ) -&gt; str:\n        \"\"\"\n        Generate a single sentence, optionally punctuated, using words (and/or numbers).\n\n        A sentence is created by calling `words(...)`, then (optionally) punctuating the\n        resulting list.\n\n        Args:\n            vocab (str | None): Name of the Vocab to use. If None, use the default Vocab.\n            glyphs (str | None): Allowed glyphs. If None, uses default glyphs.\n            seed (any): Seed for the random number generator. If None, current state is used.\n            punc (bool): Whether to add punctuation to the sentence.\n            rnd_punc (float): A randomness factor between 0 and 1 that adjusts the punctuation\n                frequency or distribution.\n            **words_kwargs: Additional keyword arguments passed to `words(...)`.\n\n        Returns:\n            str: A single sentence, optionally with punctuation.\n\n        Raises:\n            ValueError: If `rnd_punc` is not in [0, 1].\n        \"\"\"\n        glyphs = self.glyphs if glyphs is None else glyphs\n        vocab_obj = self.get_vocab(vocab)\n\n        if seed is not None:\n            self._rand.seed(seed)\n\n        word_list = self.words(\n            glyphs=glyphs,\n            vocab=vocab,\n            **words_kwargs,\n        )\n\n        if punc:\n            if not (0 &lt;= rnd_punc &lt;= 1):\n                raise ValueError(\"'rnd_punc' must be between 0 and 1\")\n\n            if vocab_obj.punctuation:\n                punctuation = vocab_obj.punctuation\n            else:\n                try:\n                    try:\n                        punctuation = DEFAULT_PUNCTUATION[vocab_obj.lang]\n                    except KeyError:\n                        # If no default punctuation is found, return unpunctuated sentence\n                        return \" \".join(word_list)\n                except KeyError:\n                    # If no default punctuation is found, return unpunctuated sentence\n                    return \" \".join(word_list)\n\n            return _punctuate(\n                punctuation,\n                self._rand,\n                word_list,\n                glyphs,\n                rnd_punc,\n            )\n        else:\n            return \" \".join(word_list)\n\n    def sents(\n        self,\n        seed=None,\n        min_n_sents: int = 3,\n        max_n_sents: int = 5,\n        n_sents: int | None = None,\n        **sent_kwargs,\n    ) -&gt; list[str]:\n        \"\"\"\n        Generate multiple sentences with `sent(...)`, returned as a list.\n\n        Args:\n            seed (float | str | None): Seed the random number generator if seed is not\n                None.\n            min_n_sents (int): Minimum number of sentences to produce if `n_sents` is None.\n            max_n_sents (int): Maximum number of sentences to produce if `n_sents` is None.\n            n_sents (int | None): If specified, exactly that many sentences are produced.\n            **sent_kwargs: Additional keyword arguments passed to `sent(...)`.\n\n        Returns:\n            list[str]: A list of generated sentences.\n        \"\"\"\n        if seed is not None:\n            self._rand.seed(seed)\n\n        if not n_sents:\n            n_sents = self._rand.randint(min_n_sents, max_n_sents)\n\n        return [self.sent(**sent_kwargs) for _ in range(n_sents)]\n\n    def para(\n        self,\n        seed=None,\n        sent_sep: str = \" \",\n        **sents_kwargs,\n    ) -&gt; str:\n        \"\"\"\n        Generate a paragraph by creating multiple sentences with `sents(...)` and\n        joining them with `sent_sep`.\n\n        Args:\n            seed (float | str | None): Seed the random number generator if seed is not\n                None.\n            sent_sep (str): The string used to join sentences.\n            **sents_kwargs: Keyword arguments passed to `sents(...)`.\n\n        Returns:\n            str: A single paragraph containing multiple sentences.\n        \"\"\"\n        if seed is not None:\n            self._rand.seed(seed)\n\n        return sent_sep.join(self.sents(**sents_kwargs))\n\n    def paras(\n        self,\n        seed=None,\n        n_paras: int = 3,\n        **para_kwargs,\n    ) -&gt; list[str]:\n        \"\"\"\n        Generate multiple paragraphs with `para(...)`, returned as a list.\n\n        Args:\n            seed (float | str | None): Seed the random number generator if seed is not\n                None.\n            n_paras (int): Number of paragraphs to generate.\n            **para_kwargs: Additional keyword arguments passed to `para(...)`.\n\n        Returns:\n            list[str]: A list of paragraphs.\n        \"\"\"\n        if seed is not None:\n            self._rand.seed(seed)\n\n        return [self.para(**para_kwargs) for _ in range(n_paras)]\n\n    def text(\n        self,\n        seed: float | str | None = None,\n        para_sep: str = \"\\n\\n\",\n        **paras_kwargs,\n    ) -&gt; str:\n        \"\"\"\n        Generate multiple paragraphs of text, calling `paras(...)` and joining them with\n        `para_sep`.\n\n        Args:\n            seed (float | str | None): Seed the random number generator if seed is not\n                None.\n            para_sep (str): The string used to separate paragraphs in the final text.\n            **paras_kwargs: Additional keyword arguments passed to `paras(...)`.\n\n        Returns:\n            str: A string containing multiple paragraphs of text, separated by\n                `para_sep`.\n        \"\"\"\n        if seed is not None:\n            self._rand.seed(seed)\n\n        return para_sep.join(self.paras(**paras_kwargs))\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.add_vocab","title":"add_vocab","text":"<pre><code>add_vocab(vocab_name, vocab)\n</code></pre> <p>Add a <code>Vocab</code> object to this <code>WordSiv</code> instance under a given name.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_name</code> <code>str</code> <p>The unique identifier for this Vocab.</p> required <code>vocab</code> <code>Vocab</code> <p>The <code>Vocab</code> object to be associated with <code>vocab_name</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def add_vocab(self, vocab_name: str, vocab: Vocab) -&gt; None:\n    \"\"\"\n    Add a `Vocab` object to this `WordSiv` instance under a given name.\n\n    Args:\n        vocab_name (str): The unique identifier for this Vocab.\n        vocab (Vocab): The `Vocab` object to be associated with `vocab_name`.\n\n    Returns:\n        None\n    \"\"\"\n    self._vocab_lookup[vocab_name] = vocab\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.get_vocab","title":"get_vocab","text":"<pre><code>get_vocab(vocab_name=None)\n</code></pre> <p>Retrieve a <code>Vocab</code> by name, or return the default Vocab if <code>vocab_name</code> is None.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_name</code> <code>str | None</code> <p>The name of the Vocab to retrieve. If None, use the default <code>self.vocab</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Vocab</code> <code>Vocab</code> <p>The <code>Vocab</code> object corresponding to <code>vocab_name</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no <code>vocab_name</code> is provided and no default is set.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def get_vocab(self, vocab_name: str | None = None) -&gt; Vocab:\n    \"\"\"\n    Retrieve a `Vocab` by name, or return the default Vocab if `vocab_name` is None.\n\n    Args:\n        vocab_name (str | None): The name of the Vocab to retrieve. If None,\n            use the default `self.vocab`.\n\n    Returns:\n        Vocab: The `Vocab` object corresponding to `vocab_name`.\n\n    Raises:\n        ValueError: If no `vocab_name` is provided and no default is set.\n    \"\"\"\n    if vocab_name:\n        return self._vocab_lookup[vocab_name]\n    else:\n        if self.vocab:\n            return self._vocab_lookup[self.vocab]\n        else:\n            raise ValueError(\"Error: no vocab specified\")\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.list_vocabs","title":"list_vocabs","text":"<pre><code>list_vocabs()\n</code></pre> <p>Return a list of all available Vocab names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of all registered Vocab names in this <code>WordSiv</code>.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def list_vocabs(self) -&gt; list[str]:\n    \"\"\"\n    Return a list of all available Vocab names.\n\n    Returns:\n        list[str]: A list of all registered Vocab names in this `WordSiv`.\n    \"\"\"\n    return list(self._vocab_lookup.keys())\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.number","title":"number","text":"<pre><code>number(\n    seed=None,\n    glyphs=None,\n    wl=None,\n    min_wl=1,\n    max_wl=_DEFAULT_MAX_NUM_LENGTH,\n    raise_errors=False,\n)\n</code></pre> <p>Generate a random numeric string (made of digits) constrained by glyphs and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>glyphs</code> <code>str | None</code> <p>A string of allowed glyphs. If None, uses the default glyphs of this <code>WordSiv</code> instance.</p> <code>None</code> <code>wl</code> <code>int | None</code> <p>Exact length of the generated numeric string. If None, a random length between <code>min_wl</code> and <code>max_wl</code> is chosen.</p> <code>None</code> <code>min_wl</code> <code>int</code> <p>Minimum length of the numeric string. Defaults to 1.</p> <code>1</code> <code>max_wl</code> <code>int</code> <p>Maximum length of the numeric string. Defaults to 4.</p> <code>_DEFAULT_MAX_NUM_LENGTH</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise an error if no numerals are available.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A randomly generated string consisting of numerals.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>min_wl</code> is greater than <code>max_wl</code>.</p> <code>FilterError</code> <p>If no numerals are available in <code>glyphs</code> and <code>raise_errors</code> is True.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def number(\n    self,\n    seed: float | str | None = None,\n    glyphs: str | None = None,\n    wl: int | None = None,\n    min_wl: int = 1,\n    max_wl: int = _DEFAULT_MAX_NUM_LENGTH,\n    raise_errors: bool = False,\n) -&gt; str:\n    \"\"\"\n    Generate a random numeric string (made of digits) constrained by glyphs and\n    other parameters.\n\n    Args:\n        seed (float | str | None): Seed the random number generator if seed is not\n            None.\n        glyphs (str | None): A string of allowed glyphs. If None, uses the default\n            glyphs of this `WordSiv` instance.\n        wl (int | None): Exact length of the generated numeric string. If None, a\n            random length between `min_wl` and `max_wl` is chosen.\n        min_wl (int): Minimum length of the numeric string. Defaults to 1.\n        max_wl (int): Maximum length of the numeric string. Defaults to 4.\n        raise_errors (bool): Whether to raise an error if no numerals are available.\n\n    Returns:\n        str: A randomly generated string consisting of numerals.\n\n    Raises:\n        ValueError: If `min_wl` is greater than `max_wl`.\n        FilterError: If no numerals are available in `glyphs` and `raise_errors` is\n            True.\n    \"\"\"\n    glyphs = self.glyphs if glyphs is None else glyphs\n    raise_errors = self.raise_errors if raise_errors is None else raise_errors\n\n    if seed is not None:\n        self._rand.seed(seed)\n\n    if wl:\n        length = wl\n    else:\n        if min_wl &gt; max_wl:\n            raise ValueError(\"'min_wl' must be less than or equal to 'max_wl'\")\n        length = self._rand.randint(min_wl, max_wl)\n\n    available_numerals = \"\".join(str(n) for n in range(0, 10))\n    if glyphs:\n        available_numerals = \"\".join(n for n in available_numerals if n in glyphs)\n\n        if not available_numerals:\n            if raise_errors:\n                raise FilterError(\"No numerals available in glyphs\")\n            else:\n                log.warning(\"No numerals available in glyphs\")\n                return \"\"\n\n    return \"\".join(self._rand.choice(available_numerals) for _ in range(length))\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.para","title":"para","text":"<pre><code>para(seed=None, sent_sep=' ', **sents_kwargs)\n</code></pre> <p>Generate a paragraph by creating multiple sentences with <code>sents(...)</code> and joining them with <code>sent_sep</code>.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>sent_sep</code> <code>str</code> <p>The string used to join sentences.</p> <code>' '</code> <code>**sents_kwargs</code> <p>Keyword arguments passed to <code>sents(...)</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single paragraph containing multiple sentences.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def para(\n    self,\n    seed=None,\n    sent_sep: str = \" \",\n    **sents_kwargs,\n) -&gt; str:\n    \"\"\"\n    Generate a paragraph by creating multiple sentences with `sents(...)` and\n    joining them with `sent_sep`.\n\n    Args:\n        seed (float | str | None): Seed the random number generator if seed is not\n            None.\n        sent_sep (str): The string used to join sentences.\n        **sents_kwargs: Keyword arguments passed to `sents(...)`.\n\n    Returns:\n        str: A single paragraph containing multiple sentences.\n    \"\"\"\n    if seed is not None:\n        self._rand.seed(seed)\n\n    return sent_sep.join(self.sents(**sents_kwargs))\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.paras","title":"paras","text":"<pre><code>paras(seed=None, n_paras=3, **para_kwargs)\n</code></pre> <p>Generate multiple paragraphs with <code>para(...)</code>, returned as a list.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>n_paras</code> <code>int</code> <p>Number of paragraphs to generate.</p> <code>3</code> <code>**para_kwargs</code> <p>Additional keyword arguments passed to <code>para(...)</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of paragraphs.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def paras(\n    self,\n    seed=None,\n    n_paras: int = 3,\n    **para_kwargs,\n) -&gt; list[str]:\n    \"\"\"\n    Generate multiple paragraphs with `para(...)`, returned as a list.\n\n    Args:\n        seed (float | str | None): Seed the random number generator if seed is not\n            None.\n        n_paras (int): Number of paragraphs to generate.\n        **para_kwargs: Additional keyword arguments passed to `para(...)`.\n\n    Returns:\n        list[str]: A list of paragraphs.\n    \"\"\"\n    if seed is not None:\n        self._rand.seed(seed)\n\n    return [self.para(**para_kwargs) for _ in range(n_paras)]\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.seed","title":"seed","text":"<pre><code>seed(seed=None)\n</code></pre> <p>Seed the random number generator for reproducible results.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>float | str | None</code> <p>The seed value used to initialize the random number generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def seed(self, seed: float | str | None = None) -&gt; None:\n    \"\"\"\n    Seed the random number generator for reproducible results.\n\n    Args:\n        seed (float | str | None): The seed value used to initialize the random\n            number generator.\n\n    Returns:\n        None\n    \"\"\"\n    self._rand.seed(seed)\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.sent","title":"sent","text":"<pre><code>sent(\n    vocab=None,\n    glyphs=None,\n    seed=None,\n    punc=True,\n    rnd_punc=0,\n    **words_kwargs,\n)\n</code></pre> <p>Generate a single sentence, optionally punctuated, using words (and/or numbers).</p> <p>A sentence is created by calling <code>words(...)</code>, then (optionally) punctuating the resulting list.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str | None</code> <p>Name of the Vocab to use. If None, use the default Vocab.</p> <code>None</code> <code>glyphs</code> <code>str | None</code> <p>Allowed glyphs. If None, uses default glyphs.</p> <code>None</code> <code>seed</code> <code>any</code> <p>Seed for the random number generator. If None, current state is used.</p> <code>None</code> <code>punc</code> <code>bool</code> <p>Whether to add punctuation to the sentence.</p> <code>True</code> <code>rnd_punc</code> <code>float</code> <p>A randomness factor between 0 and 1 that adjusts the punctuation frequency or distribution.</p> <code>0</code> <code>**words_kwargs</code> <p>Additional keyword arguments passed to <code>words(...)</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single sentence, optionally with punctuation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>rnd_punc</code> is not in [0, 1].</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def sent(\n    self,\n    vocab: str | None = None,\n    glyphs: str | None = None,\n    seed=None,\n    punc: bool = True,\n    rnd_punc: float = 0,\n    **words_kwargs,\n) -&gt; str:\n    \"\"\"\n    Generate a single sentence, optionally punctuated, using words (and/or numbers).\n\n    A sentence is created by calling `words(...)`, then (optionally) punctuating the\n    resulting list.\n\n    Args:\n        vocab (str | None): Name of the Vocab to use. If None, use the default Vocab.\n        glyphs (str | None): Allowed glyphs. If None, uses default glyphs.\n        seed (any): Seed for the random number generator. If None, current state is used.\n        punc (bool): Whether to add punctuation to the sentence.\n        rnd_punc (float): A randomness factor between 0 and 1 that adjusts the punctuation\n            frequency or distribution.\n        **words_kwargs: Additional keyword arguments passed to `words(...)`.\n\n    Returns:\n        str: A single sentence, optionally with punctuation.\n\n    Raises:\n        ValueError: If `rnd_punc` is not in [0, 1].\n    \"\"\"\n    glyphs = self.glyphs if glyphs is None else glyphs\n    vocab_obj = self.get_vocab(vocab)\n\n    if seed is not None:\n        self._rand.seed(seed)\n\n    word_list = self.words(\n        glyphs=glyphs,\n        vocab=vocab,\n        **words_kwargs,\n    )\n\n    if punc:\n        if not (0 &lt;= rnd_punc &lt;= 1):\n            raise ValueError(\"'rnd_punc' must be between 0 and 1\")\n\n        if vocab_obj.punctuation:\n            punctuation = vocab_obj.punctuation\n        else:\n            try:\n                try:\n                    punctuation = DEFAULT_PUNCTUATION[vocab_obj.lang]\n                except KeyError:\n                    # If no default punctuation is found, return unpunctuated sentence\n                    return \" \".join(word_list)\n            except KeyError:\n                # If no default punctuation is found, return unpunctuated sentence\n                return \" \".join(word_list)\n\n        return _punctuate(\n            punctuation,\n            self._rand,\n            word_list,\n            glyphs,\n            rnd_punc,\n        )\n    else:\n        return \" \".join(word_list)\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.sents","title":"sents","text":"<pre><code>sents(\n    seed=None,\n    min_n_sents=3,\n    max_n_sents=5,\n    n_sents=None,\n    **sent_kwargs,\n)\n</code></pre> <p>Generate multiple sentences with <code>sent(...)</code>, returned as a list.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>min_n_sents</code> <code>int</code> <p>Minimum number of sentences to produce if <code>n_sents</code> is None.</p> <code>3</code> <code>max_n_sents</code> <code>int</code> <p>Maximum number of sentences to produce if <code>n_sents</code> is None.</p> <code>5</code> <code>n_sents</code> <code>int | None</code> <p>If specified, exactly that many sentences are produced.</p> <code>None</code> <code>**sent_kwargs</code> <p>Additional keyword arguments passed to <code>sent(...)</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of generated sentences.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def sents(\n    self,\n    seed=None,\n    min_n_sents: int = 3,\n    max_n_sents: int = 5,\n    n_sents: int | None = None,\n    **sent_kwargs,\n) -&gt; list[str]:\n    \"\"\"\n    Generate multiple sentences with `sent(...)`, returned as a list.\n\n    Args:\n        seed (float | str | None): Seed the random number generator if seed is not\n            None.\n        min_n_sents (int): Minimum number of sentences to produce if `n_sents` is None.\n        max_n_sents (int): Maximum number of sentences to produce if `n_sents` is None.\n        n_sents (int | None): If specified, exactly that many sentences are produced.\n        **sent_kwargs: Additional keyword arguments passed to `sent(...)`.\n\n    Returns:\n        list[str]: A list of generated sentences.\n    \"\"\"\n    if seed is not None:\n        self._rand.seed(seed)\n\n    if not n_sents:\n        n_sents = self._rand.randint(min_n_sents, max_n_sents)\n\n    return [self.sent(**sent_kwargs) for _ in range(n_sents)]\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.text","title":"text","text":"<pre><code>text(seed=None, para_sep='\\n\\n', **paras_kwargs)\n</code></pre> <p>Generate multiple paragraphs of text, calling <code>paras(...)</code> and joining them with <code>para_sep</code>.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>para_sep</code> <code>str</code> <p>The string used to separate paragraphs in the final text.</p> <code>'\\n\\n'</code> <code>**paras_kwargs</code> <p>Additional keyword arguments passed to <code>paras(...)</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing multiple paragraphs of text, separated by <code>para_sep</code>.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def text(\n    self,\n    seed: float | str | None = None,\n    para_sep: str = \"\\n\\n\",\n    **paras_kwargs,\n) -&gt; str:\n    \"\"\"\n    Generate multiple paragraphs of text, calling `paras(...)` and joining them with\n    `para_sep`.\n\n    Args:\n        seed (float | str | None): Seed the random number generator if seed is not\n            None.\n        para_sep (str): The string used to separate paragraphs in the final text.\n        **paras_kwargs: Additional keyword arguments passed to `paras(...)`.\n\n    Returns:\n        str: A string containing multiple paragraphs of text, separated by\n            `para_sep`.\n    \"\"\"\n    if seed is not None:\n        self._rand.seed(seed)\n\n    return para_sep.join(self.paras(**paras_kwargs))\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.top_word","title":"top_word","text":"<pre><code>top_word(\n    vocab=None,\n    glyphs=None,\n    seed=None,\n    idx=0,\n    case=\"any\",\n    min_wl=2,\n    max_wl=None,\n    wl=None,\n    contains=None,\n    inner=None,\n    startswith=None,\n    endswith=None,\n    regexp=None,\n    raise_errors=False,\n)\n</code></pre> <p>Retrieve the most common (or nth most common) word from the Vocab, subject to filtering constraints.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str | None</code> <p>Name of the Vocab to use. If None, use the default Vocab.</p> <code>None</code> <code>glyphs</code> <code>str | None</code> <p>Whitelisted glyphs to filter words. If None, uses default.</p> <code>None</code> <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>idx</code> <code>int</code> <p>Index of the desired word in the frequency-sorted list (0-based).</p> <code>0</code> <code>case</code> <code>CaseType</code> <p>Desired case form for the word (e.g., 'lower', 'upper', 'any').</p> <code>'any'</code> <code>min_wl</code> <code>int</code> <p>Minimum word length.</p> <code>2</code> <code>max_wl</code> <code>int | None</code> <p>Maximum word length. If None, no maximum.</p> <code>None</code> <code>wl</code> <code>int | None</code> <p>Exact word length. If None, no exact length filter.</p> <code>None</code> <code>contains</code> <code>str | Sequence[str] | None</code> <p>Substring(s) that must appear in the word.</p> <code>None</code> <code>inner</code> <code>str | Sequence[str] | None</code> <p>Substring(s) that must appear in the interior.</p> <code>None</code> <code>startswith</code> <code>str | None</code> <p>Substring that the word must start with.</p> <code>None</code> <code>endswith</code> <code>str | None</code> <p>Substring that the word must end with.</p> <code>None</code> <code>regexp</code> <code>str | None</code> <p>Regex pattern that the word must match.</p> <code>None</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors on filter or index failures.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The nth most common word that meets the constraints (or an empty string on failure if <code>raise_errors</code> is False).</p> <p>Raises:</p> Type Description <code>FilterError</code> <p>If filtering fails (no words match) and <code>raise_errors</code> is True.</p> <code>ValueError</code> <p>If no default vocab is set when <code>vocab</code> is None.</p> <code>IndexError</code> <p>If <code>idx</code> is out of range after filtering and <code>raise_errors</code> is True.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def top_word(\n    self,\n    vocab: str | None = None,\n    glyphs: str | None = None,\n    seed: float | str | None = None,\n    idx: int = 0,\n    case: CaseType = \"any\",\n    min_wl: int = 2,\n    max_wl: int | None = None,\n    wl: int | None = None,\n    contains: str | Sequence[str] | None = None,\n    inner: str | Sequence[str] | None = None,\n    startswith: str | None = None,\n    endswith: str | None = None,\n    regexp: str | None = None,\n    raise_errors: bool = False,\n) -&gt; str:\n    \"\"\"\n    Retrieve the most common (or nth most common) word from the Vocab, subject to\n    filtering constraints.\n\n    Args:\n        vocab (str | None): Name of the Vocab to use. If None, use the default\n            Vocab.\n        glyphs (str | None): Whitelisted glyphs to filter words. If None, uses\n            default.\n        seed (float | str | None): Seed the random number generator if seed is\n            not None.\n        idx (int): Index of the desired word in the frequency-sorted list\n            (0-based).\n        case (CaseType): Desired case form for the word (e.g., 'lower', 'upper',\n            'any').\n        min_wl (int): Minimum word length.\n        max_wl (int | None): Maximum word length. If None, no maximum.\n        wl (int | None): Exact word length. If None, no exact length filter.\n        contains (str | Sequence[str] | None): Substring(s) that must appear in\n            the word.\n        inner (str | Sequence[str] | None): Substring(s) that must appear in the\n            interior.\n        startswith (str | None): Substring that the word must start with.\n        endswith (str | None): Substring that the word must end with.\n        regexp (str | None): Regex pattern that the word must match.\n        raise_errors (bool): Whether to raise errors on filter or index failures.\n\n    Returns:\n        str: The nth most common word that meets the constraints (or an empty string\n            on failure if `raise_errors` is False).\n\n    Raises:\n        FilterError: If filtering fails (no words match) and `raise_errors` is True.\n        ValueError: If no default vocab is set when `vocab` is None.\n        IndexError: If `idx` is out of range after filtering and `raise_errors` is\n            True.\n    \"\"\"\n    glyphs = self.glyphs if glyphs is None else glyphs\n    raise_errors = self.raise_errors if raise_errors is None else raise_errors\n    vocab_obj = self.get_vocab(self.vocab) if not vocab else self.get_vocab(vocab)\n\n    try:\n        wc_list = vocab_obj.filter(\n            glyphs=glyphs,\n            case=case,\n            min_wl=min_wl,\n            max_wl=max_wl,\n            wl=wl,\n            contains=contains,\n            inner=inner,\n            startswith=startswith,\n            endswith=endswith,\n            regexp=regexp,\n        )\n    except FilterError as e:\n        if raise_errors:\n            raise e\n        else:\n            log.warning(\"%s\", e.args[0])\n            return \"\"\n\n    try:\n        return wc_list[idx][0]\n    except IndexError:\n        if raise_errors:\n            raise FilterError(f\"No word at index idx='{idx}'\")\n        else:\n            log.warning(\"No word at index idx='%s'\", idx)\n            return \"\"\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.top_words","title":"top_words","text":"<pre><code>top_words(\n    glyphs=None,\n    vocab=None,\n    n_words=10,\n    idx=0,\n    case=\"any\",\n    min_wl=1,\n    max_wl=None,\n    wl=None,\n    contains=None,\n    inner=None,\n    startswith=None,\n    endswith=None,\n    regexp=None,\n    raise_errors=False,\n)\n</code></pre> <p>Retrieve the top <code>n_words</code> from the Vocab, starting at index <code>idx</code>, subject to filtering constraints.</p> <p>Parameters:</p> Name Type Description Default <code>glyphs</code> <code>str | None</code> <p>Allowed glyph set. If None, uses default glyphs.</p> <code>None</code> <code>vocab</code> <code>str | None</code> <p>Name of the Vocab to use. If None, use the default Vocab.</p> <code>None</code> <code>n_words</code> <code>int</code> <p>Number of words to return.</p> <code>10</code> <code>idx</code> <code>int</code> <p>The index at which to start returning words (0-based).</p> <code>0</code> <code>case</code> <code>CaseType</code> <p>Desired case form (\"any\", \"upper\", \"lower\", etc.).</p> <code>'any'</code> <code>min_wl</code> <code>int</code> <p>Minimum word length. Defaults to 1.</p> <code>1</code> <code>max_wl</code> <code>int | None</code> <p>Maximum word length. If None, no maximum is applied.</p> <code>None</code> <code>wl</code> <code>int | None</code> <p>Exact word length. If None, no exact length filter.</p> <code>None</code> <code>contains</code> <code>str | Sequence[str] | None</code> <p>Substring(s) that must appear.</p> <code>None</code> <code>inner</code> <code>str | Sequence[str] | None</code> <p>Substring(s) that must appear, not at edges.</p> <code>None</code> <code>startswith</code> <code>str | None</code> <p>Required starting substring.</p> <code>None</code> <code>endswith</code> <code>str | None</code> <p>Required ending substring.</p> <code>None</code> <code>regexp</code> <code>str | None</code> <p>Regex pattern(s) to match.</p> <code>None</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors or fail gently.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of up to <code>n_words</code> words, in descending frequency order.</p> <p>Raises:</p> Type Description <code>FilterError</code> <p>If filtering fails (no words match) and <code>raise_errors</code> is True.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def top_words(\n    self,\n    glyphs: str | None = None,\n    vocab: str | None = None,\n    n_words: int = 10,\n    idx: int = 0,\n    case: CaseType = \"any\",\n    min_wl: int = 1,\n    max_wl: int | None = None,\n    wl: int | None = None,\n    contains: str | Sequence[str] | None = None,\n    inner: str | Sequence[str] | None = None,\n    startswith: str | None = None,\n    endswith: str | None = None,\n    regexp: str | None = None,\n    raise_errors: bool = False,\n) -&gt; list[str]:\n    \"\"\"\n    Retrieve the top `n_words` from the Vocab, starting at index `idx`, subject to\n    filtering constraints.\n\n    Args:\n        glyphs (str | None): Allowed glyph set. If None, uses default glyphs.\n        vocab (str | None): Name of the Vocab to use. If None, use the default\n            Vocab.\n        n_words (int): Number of words to return.\n        idx (int): The index at which to start returning words (0-based).\n        case (CaseType): Desired case form (\"any\", \"upper\", \"lower\", etc.).\n        min_wl (int): Minimum word length. Defaults to 1.\n        max_wl (int | None): Maximum word length. If None, no maximum is applied.\n        wl (int | None): Exact word length. If None, no exact length filter.\n        contains (str | Sequence[str] | None): Substring(s) that must appear.\n        inner (str | Sequence[str] | None): Substring(s) that must appear, not at\n            edges.\n        startswith (str | None): Required starting substring.\n        endswith (str | None): Required ending substring.\n        regexp (str | None): Regex pattern(s) to match.\n        raise_errors (bool): Whether to raise errors or fail gently.\n\n    Returns:\n        list[str]: A list of up to `n_words` words, in descending frequency order.\n\n    Raises:\n        FilterError: If filtering fails (no words match) and `raise_errors` is True.\n    \"\"\"\n    glyphs = self.glyphs if glyphs is None else glyphs\n    vocab_obj = self.get_vocab(self.vocab) if not vocab else self.get_vocab(vocab)\n\n    try:\n        wc_list = vocab_obj.filter(\n            glyphs=glyphs,\n            case=case,\n            min_wl=min_wl,\n            max_wl=max_wl,\n            wl=wl,\n            contains=contains,\n            inner=inner,\n            startswith=startswith,\n            endswith=endswith,\n            regexp=regexp,\n        )[idx : idx + n_words]\n    except FilterError as e:\n        if raise_errors:\n            raise e\n        else:\n            log.warning(\"%s\", e.args[0])\n            return []\n\n    if not wc_list:\n        if raise_errors:\n            raise FilterError(f\"No words found at idx '{idx}'\")\n        else:\n            log.warning(\"No words found at idx '%s'\", idx)\n            return []\n\n    return [w for w, _ in wc_list]\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.word","title":"word","text":"<pre><code>word(\n    vocab=None,\n    glyphs=None,\n    seed=None,\n    rnd=0,\n    case=\"any\",\n    top_k=0,\n    min_wl=1,\n    max_wl=None,\n    wl=None,\n    contains=None,\n    inner=None,\n    startswith=None,\n    endswith=None,\n    regexp=None,\n    raise_errors=False,\n)\n</code></pre> <p>Generate a random word that meets a variety of constraints, such as glyphs, length, regex filters, etc.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str | None</code> <p>Name of the Vocab to use. If None, uses default Vocab.</p> <code>None</code> <code>glyphs</code> <code>str | None</code> <p>A string of allowed glyphs. If None, uses default glyphs.</p> <code>None</code> <code>seed</code> <code>float | str | None</code> <p>Seed the random number generator if seed is not None.</p> <code>None</code> <code>rnd</code> <code>float</code> <p>Randomness factor in [0, 1] for selecting among the top words.</p> <code>0</code> <code>case</code> <code>CaseType</code> <p>Desired case of the output word (e.g., 'upper', 'lower', 'any').</p> <code>'any'</code> <code>top_k</code> <code>int</code> <p>If &gt; 0, only consider the top K words by frequency.</p> <code>0</code> <code>min_wl</code> <code>int</code> <p>Minimum word length.</p> <code>1</code> <code>max_wl</code> <code>int | None</code> <p>Maximum word length. If None, no maximum is applied.</p> <code>None</code> <code>wl</code> <code>int | None</code> <p>Exact word length. If None, no exact length is enforced.</p> <code>None</code> <code>contains</code> <code>str | Sequence[str] | None</code> <p>Substring(s) that must appear in the word.</p> <code>None</code> <code>inner</code> <code>str | Sequence[str] | None</code> <p>Substring(s) that must appear, but not at the start or end of the word.</p> <code>None</code> <code>startswith</code> <code>str | None</code> <p>Required starting substring.</p> <code>None</code> <code>endswith</code> <code>str | None</code> <p>Required ending substring.</p> <code>None</code> <code>regexp</code> <code>str | None</code> <p>A regular expression that the word must match.</p> <code>None</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise filtering errors or fail gently.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A randomly generated word meeting the specified constraints (or an empty string on failure if <code>raise_errors</code> is False).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>rnd</code> is not in [0, 1].</p> <code>FilterError</code> <p>If filtering yields no results and <code>raise_errors</code> is True.</p> <code>VocabFormatError</code> <p>If the underlying Vocab data is malformed.</p> <code>VocabEmptyError</code> <p>If the underlying Vocab is empty.</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def word(\n    self,\n    vocab: str | None = None,\n    glyphs: str | None = None,\n    seed: float | str | None = None,\n    rnd: float = 0,\n    case: CaseType = \"any\",\n    top_k: int = 0,\n    min_wl: int = 1,\n    max_wl: int | None = None,\n    wl: int | None = None,\n    contains: str | Sequence[str] | None = None,\n    inner: str | Sequence[str] | None = None,\n    startswith: str | None = None,\n    endswith: str | None = None,\n    regexp: str | None = None,\n    raise_errors: bool = False,\n) -&gt; str:\n    \"\"\"\n    Generate a random word that meets a variety of constraints, such as glyphs,\n    length, regex filters, etc.\n\n    Args:\n        vocab (str | None): Name of the Vocab to use. If None, uses default Vocab.\n        glyphs (str | None): A string of allowed glyphs. If None, uses default\n            glyphs.\n        seed (float | str | None): Seed the random number generator if seed is not\n            None.\n        rnd (float): Randomness factor in [0, 1] for selecting among the top words.\n        case (CaseType): Desired case of the output word (e.g., 'upper', 'lower',\n            'any').\n        top_k (int): If &gt; 0, only consider the top K words by frequency.\n        min_wl (int): Minimum word length.\n        max_wl (int | None): Maximum word length. If None, no maximum is applied.\n        wl (int | None): Exact word length. If None, no exact length is enforced.\n        contains (str | Sequence[str] | None): Substring(s) that must appear in the\n            word.\n        inner (str | Sequence[str] | None): Substring(s) that must appear, but not\n            at the start or end of the word.\n        startswith (str | None): Required starting substring.\n        endswith (str | None): Required ending substring.\n        regexp (str | None): A regular expression that the word must match.\n        raise_errors (bool): Whether to raise filtering errors or fail gently.\n\n    Returns:\n        str: A randomly generated word meeting the specified constraints (or an\n            empty string on failure if `raise_errors` is False).\n\n    Raises:\n        ValueError: If `rnd` is not in [0, 1].\n        FilterError: If filtering yields no results and `raise_errors` is True.\n        VocabFormatError: If the underlying Vocab data is malformed.\n        VocabEmptyError: If the underlying Vocab is empty.\n    \"\"\"\n    glyphs = self.glyphs if glyphs is None else glyphs\n    raise_errors = self.raise_errors if raise_errors is None else raise_errors\n    vocab_obj = self.get_vocab(vocab)\n\n    if not (0 &lt;= rnd &lt;= 1):\n        raise ValueError(\"'rnd' must be between 0 and 1\")\n\n    if seed is not None:\n        self._rand.seed(seed)\n\n    try:\n        wc_list = vocab_obj.filter(\n            glyphs=glyphs,\n            case=case,\n            min_wl=min_wl,\n            max_wl=max_wl,\n            wl=wl,\n            contains=contains,\n            inner=inner,\n            startswith=startswith,\n            endswith=endswith,\n            regexp=regexp,\n        )\n    except FilterError as e:\n        if raise_errors:\n            raise e\n        else:\n            log.warning(\"%s\", e.args[0])\n            return \"\"\n\n    if top_k:\n        wc_list = wc_list[:top_k]\n\n    return _sample_word(wc_list, self._rand, rnd)\n</code></pre>"},{"location":"api-reference/#wordsiv.WordSiv.words","title":"words","text":"<pre><code>words(\n    vocab=None,\n    glyphs=None,\n    seed=None,\n    n_words=None,\n    min_n_words=10,\n    max_n_words=20,\n    numbers=0,\n    cap_first=None,\n    case=\"any\",\n    rnd=0,\n    min_wl=1,\n    max_wl=None,\n    wl=None,\n    raise_errors=False,\n    **word_kwargs,\n)\n</code></pre> <p>Generate a list of words (and optionally numbers) according to the specified parameters.</p> <p>This method will produce <code>n_words</code> tokens, each of which may be a word or a number (digit string), depending on the <code>numbers</code> ratio. It can also automatically handle capitalization of the first token if <code>cap_first</code> is True (or inferred).</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str | None</code> <p>Name of the Vocab to use. If None, uses the default Vocab.</p> <code>None</code> <code>glyphs</code> <code>str | None</code> <p>Allowed glyph set. If None, uses the default glyphs.</p> <code>None</code> <code>seed</code> <code>any</code> <p>Seed for the random number generator. If None, current state is used.</p> <code>None</code> <code>n_words</code> <code>int | None</code> <p>Exact number of tokens to generate. If None, randomly choose between <code>min_n_words</code> and <code>max_n_words</code>.</p> <code>None</code> <code>min_n_words</code> <code>int</code> <p>Minimum number of tokens if <code>n_words</code> is not specified.</p> <code>10</code> <code>max_n_words</code> <code>int</code> <p>Maximum number of tokens if <code>n_words</code> is not specified.</p> <code>20</code> <code>numbers</code> <code>float</code> <p>A value in [0, 1] that determines the probability of generating a numeric token instead of a word.</p> <code>0</code> <code>cap_first</code> <code>bool | None</code> <p>If True, capitalize the first word (if <code>case</code> is \"any\"). If None, automatically decide based on glyphs availability.</p> <code>None</code> <code>case</code> <code>CaseType</code> <p>Desired case form for the words (\"any\", \"lower\", \"upper\", etc.).</p> <code>'any'</code> <code>rnd</code> <code>float</code> <p>Randomness factor for word selection, in [0, 1].</p> <code>0</code> <code>min_wl</code> <code>int</code> <p>Minimum length for words/numbers.</p> <code>1</code> <code>max_wl</code> <code>int</code> <p>Maximum length for words/numbers.</p> <code>None</code> <code>wl</code> <code>int | None</code> <p>Exact length for words/numbers. If None, uses min/max_wl.</p> <code>None</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors or fail gently.</p> <code>False</code> <code>**word_kwargs</code> <p>Additional keyword arguments passed along to <code>word()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of randomly generated tokens (words or numbers).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>numbers</code> is not in [0, 1].</p> Source code in <code>wordsiv/__init__.py</code> <pre><code>def words(\n    self,\n    vocab: str | None = None,\n    glyphs: str | None = None,\n    seed=None,\n    n_words: int | None = None,\n    min_n_words: int = 10,\n    max_n_words: int = 20,\n    numbers: float = 0,\n    cap_first: bool | None = None,\n    case: CaseType = \"any\",\n    rnd: float = 0,\n    min_wl: int = 1,\n    max_wl: int | None = None,\n    wl: int | None = None,\n    raise_errors: bool = False,\n    **word_kwargs,\n) -&gt; list[str]:\n    \"\"\"\n    Generate a list of words (and optionally numbers) according to the specified\n    parameters.\n\n    This method will produce `n_words` tokens, each of which may be a word or a\n    number (digit string), depending on the `numbers` ratio. It can also\n    automatically handle capitalization of the first token if `cap_first` is True\n    (or inferred).\n\n    Args:\n        vocab (str | None): Name of the Vocab to use. If None, uses the default\n            Vocab.\n        glyphs (str | None): Allowed glyph set. If None, uses the default glyphs.\n        seed (any): Seed for the random number generator. If None, current state is\n            used.\n        n_words (int | None): Exact number of tokens to generate. If None, randomly\n            choose between `min_n_words` and `max_n_words`.\n        min_n_words (int): Minimum number of tokens if `n_words` is not specified.\n        max_n_words (int): Maximum number of tokens if `n_words` is not specified.\n        numbers (float): A value in [0, 1] that determines the probability of\n            generating a numeric token instead of a word.\n        cap_first (bool | None): If True, capitalize the first word (if `case` is\n            \"any\"). If None, automatically decide based on glyphs availability.\n        case (CaseType): Desired case form for the words (\"any\", \"lower\", \"upper\",\n            etc.).\n        rnd (float): Randomness factor for word selection, in [0, 1].\n        min_wl (int): Minimum length for words/numbers.\n        max_wl (int): Maximum length for words/numbers.\n        wl (int | None): Exact length for words/numbers. If None, uses min/max_wl.\n        raise_errors (bool): Whether to raise errors or fail gently.\n        **word_kwargs: Additional keyword arguments passed along to `word()`.\n\n    Returns:\n        list[str]: A list of randomly generated tokens (words or numbers).\n\n    Raises:\n        ValueError: If `numbers` is not in [0, 1].\n    \"\"\"\n    glyphs = self.glyphs if glyphs is None else glyphs\n\n    if seed is not None:\n        self._rand.seed(seed)\n\n    if not n_words:\n        n_words = self._rand.randint(min_n_words, max_n_words)\n\n    if cap_first is None:\n        if glyphs:\n            # If constrained glyphs, only capitalize if uppercase letters exist\n            cap_first = any(c for c in glyphs if c.isupper())\n        else:\n            # Otherwise, default to capitalize the first word\n            cap_first = True\n\n    if not (0 &lt;= numbers &lt;= 1):\n        raise ValueError(\"'numbers' must be between 0 and 1\")\n\n    word_list = []\n    last_w = None\n    for i in range(n_words):\n        if cap_first and case == \"any\" and i == 0:\n            word_case: CaseType = \"cap\"\n        else:\n            word_case = case\n\n        token_type = self._rand.choices(\n            [\"word\", \"number\"],\n            weights=[1 - numbers, numbers],\n        )[0]\n\n        if token_type == \"word\":\n            w = self.word(\n                vocab=vocab,\n                glyphs=glyphs,\n                case=word_case,\n                rnd=rnd,\n                min_wl=min_wl,\n                max_wl=max_wl,\n                wl=wl,\n                raise_errors=raise_errors,\n                **word_kwargs,\n            )\n\n            # Try once more to avoid consecutive repeats\n            # TODO: this is a hack, we should find a better way to avoid consecutive\n            # repeats\n            if w == last_w:\n                w = self.word(\n                    vocab=vocab,\n                    glyphs=glyphs,\n                    case=word_case,\n                    rnd=rnd,\n                    min_wl=min_wl,\n                    max_wl=max_wl,\n                    wl=wl,\n                    raise_errors=raise_errors,\n                    **word_kwargs,\n                )\n\n            if w:\n                word_list.append(w)\n                last_w = w\n        else:\n            # token_type == \"number\"\n            w = self.number(\n                glyphs=glyphs,\n                wl=wl,\n                min_wl=min_wl,\n                max_wl=max_wl or _DEFAULT_MAX_NUM_LENGTH,\n                raise_errors=raise_errors,\n            )\n\n            if w:\n                word_list.append(w)\n                last_w = w\n\n    return word_list\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#031-2025-02-09","title":"0.3.1 \u2013 2025-02-09","text":""},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li>Fixed bug where brackets (<code>[]</code>) were not properly escaped from glyphs string,   causing glyph filtering to work incorrectly (thanks @jmsole!)</li> </ul>"},{"location":"release-notes/#030-2025-02-01","title":"0.3.0 \u2013 2025-02-01","text":""},{"location":"release-notes/#added","title":"Added","text":"<ul> <li>Documentation on language support</li> </ul>"},{"location":"release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>internal: <code>tests/test_snippets.py</code> now uses the current working directory</li> <li>Minor site/docs fixes</li> </ul>"},{"location":"release-notes/#removed","title":"Removed","text":"<ul> <li><code>docs/punctuation.md</code> (unused)</li> </ul>"},{"location":"release-notes/#024-2025-01-21","title":"0.2.4 \u2013 2025-01-21","text":""},{"location":"release-notes/#fixed_2","title":"Fixed","text":"<ul> <li>Minor site/docs fixes</li> </ul>"},{"location":"release-notes/#removed_1","title":"Removed","text":"<ul> <li><code>wordsiv/about.py</code>: no need to have this, package version in pyproject.toml</li> </ul>"},{"location":"release-notes/#021-022-023-2025-01-20","title":"0.2.1, 0.2.2, 0.2.3 \u2013 2025-01-20","text":""},{"location":"release-notes/#fixed_3","title":"Fixed","text":"<ul> <li>Minor site/docs fixes</li> </ul>"},{"location":"release-notes/#020-2025-01-20","title":"0.2.0 - 2025-01-20","text":""},{"location":"release-notes/#added_1","title":"Added","text":"<ul> <li>Built-in \"Vocabs\": Sources are now referred to as Vocabs, which   include English (<code>\"en\"</code>), Spanish (<code>\"es\"</code>), Arabic (<code>\"ar\"</code>), and Farsi   (<code>\"fa\"</code>) (thanks @jmsole!).<ul> <li>No extra installation required\u2014simply pass <code>vocab=\"en\"</code> (etc.) to your <code>WordSiv</code> methods.</li> <li>English (<code>\"en\"</code>) Vocab features improved capitalization for acronyms,   proper nouns, and more.</li> </ul> </li> <li>Glyphs-aware numeric string generation: The new <code>number()</code> method, plus   the <code>numbers</code> parameter (e.g., <code>numbers=0.2</code>) in <code>words()</code>, <code>sent()</code>, etc.,   allows digits to appear among words\u2014only digits present in your specified   glyph set are used.</li> <li>Top-k frequency selection: Use <code>top_word()</code> or <code>top_words()</code> to retrieve   the most common word(s) in frequency order.<ul> <li>Replaces the old <code>SequentialModel</code>: if you stepped through frequent words, call <code>top_words(n_words=...)</code> now.</li> </ul> </li> <li>Advanced word filtering: New substring and regex constraints let you   refine which words appear. In addition to <code>min_wl</code>, <code>max_wl</code>, and <code>wl</code>, you   can now use (thanks @jmsole!):<ul> <li><code>startswith=\"...\"</code></li> <li><code>endswith=\"...\"</code></li> <li><code>contains=\"...\"</code></li> <li><code>inner=\"...\"</code></li> <li><code>regexp=\"...\"</code></li> </ul> </li> <li><code>raise_errors</code> parameter: If set to <code>True</code>, WordSiv raises a <code>FilterError</code>   instead of logging a warning when no words match your filters. By default, it   logs a warning and returns an empty string.</li> </ul>"},{"location":"release-notes/#fixed_4","title":"Fixed","text":"<ul> <li>Filtering performance: WordSiv uses more efficient regex matching and   caching under the hood, greatly speeding up word filtering compared to the   previous Python-level loops.</li> <li>Default punctuation: Language-specific punctuation is refined to reflect   typical usage. Toggle it with <code>punc=True/False</code> and adjust distribution   randomness via <code>rnd_punc</code>.</li> </ul>"},{"location":"release-notes/#changed","title":"Changed","text":"<ul> <li>Single <code>case</code> parameter: Replaces multiple booleans (<code>uc</code>, <code>lc</code>, <code>cap</code>).   Use <code>case=\"any\"</code>, <code>\"lc\"</code>, <code>\"uc\"</code>, <code>\"cap\"</code>, etc. to control exactly which case   you want and whether you're willing to modify original casing (gently or   forcefully).</li> <li>Shorter method names:<ul> <li><code>sentence</code> \u2192 <code>sent</code></li> <li><code>sentences</code> \u2192 <code>sents</code></li> <li><code>paragraph</code> \u2192 <code>para</code></li> <li><code>paragraphs</code> \u2192 <code>paras</code></li> </ul> </li> <li><code>source</code> \u2192 <code>vocab</code>: Instead of passing <code>source=\"...\"</code>, specify   <code>vocab=\"...\"</code>.<ul> <li>See available Vocabs with <code>list_vocabs()</code>.</li> </ul> </li> <li>Seeding: WordSiv no longer has an internal default seed.<ul> <li>Call <code>WordSiv(seed=123)</code> or <code>wsv.seed(123)</code> for deterministic results.</li> <li>Most generation methods (e.g., <code>word()</code>, <code>words()</code>, <code>para()</code>, etc.) also accept a <code>seed</code> argument.</li> <li><code>top_word()</code> and <code>top_words()</code> do not use randomness, so <code>seed</code> is irrelevant there.</li> </ul> </li> <li>Parameter name changes:<ul> <li><code>prob=...</code> \u2192 <code>rnd=0..1</code>: controls how random vs. frequency-based word selection is (<code>rnd=0</code> = fully frequency-based, <code>rnd=1</code> = fully random).</li> <li><code>num_top=...</code> \u2192 <code>top_k=...</code>: if you need to limit to the top K words in frequency order on random picks, use <code>top_k</code>.</li> </ul> </li> </ul>"},{"location":"release-notes/#removed_2","title":"Removed","text":"<ul> <li>Models and Source Packages (<code>RandomModel</code>, <code>SequentialModel</code>,   <code>MarkovModel</code>):<ul> <li>Models have been removed, and Source Packages are replaced by Vocabs,   some of which are bundled with WordSiv itself. However:<ul> <li>RandomModel can be replicated <code>rnd=1</code>.</li> <li>SequentialModel can be replicated with <code>top_word()</code> /   <code>top_words()</code>.</li> <li>MarkovModel has no direct replacement.</li> </ul> </li> </ul> </li> <li>Font-based glyph inspection and bounding-box width filtering:<ul> <li>These relied on <code>fonttools</code> and introduced extra complexity. Inspecting   fonts is now up to the user.</li> </ul> </li> </ul>"},{"location":"examples/gj-style-proof/","title":"Proof inspired by Galvanized Jets","text":"<p>This proof attempts to do something similar to Galvanized Jets: printing words that showcase all letter permutations. In this case it dynamically adjusts to glyphs available in <code>GLYPHS_EN</code> and <code>GLYPHS_AR</code>:</p> <pre><code>\"\"\"WordSiv Proof inspired by http://www.galvanizedjets.com/\"\"\"\n\nfrom wordsiv import WordSiv\nfrom itertools import product\nimport logging\n\nGLYPHS_EN = \"HAMBUGERFONTSIVhambugerfontsiv.,\"\nGLYPHS_AR = \"\u0646\u064a\u0648\u0641\u0623\u0639\u062f\u0642\u062c\u0632\u062e\u0636\u0630\u0626\u0629\u0649\u0621\u0622\u0625\"\n\n# Quiet the output of WordSiv, since there will inevitably be a lot of word queries\n# that don't have any results when we're permuting all letters\nwsv_log = logging.getLogger(\"wordsiv\")\nwsv_log.setLevel(logging.ERROR)\n\n\ndef gj_proof_en(glyphs, case=\"cap\"):\n    wsv = WordSiv(vocab=\"en\", glyphs=glyphs)\n\n    uc_glyphs = \"\".join(sorted(c for c in glyphs if c.isupper()))\n    lc_glyphs = \"\".join(sorted(c for c in glyphs if c.islower()))\n\n    if case == \"cap\":\n        pairs = [f\"{uc}{lc}\" for uc in uc_glyphs for lc in lc_glyphs]\n    elif case == \"lc\":\n        pairs = [\"\".join(pair) for pair in product(lc_glyphs, repeat=2)]\n    elif case == \"uc\":\n        pairs = [\"\".join(pair) for pair in product(uc_glyphs, repeat=2)]\n    else:\n        raise ValueError(f\"Invalid case: {case}\")\n\n    words = []\n    for pair in pairs:\n        if case == \"cap\":\n            w = wsv.top_word(startswith=pair, case=\"cap\", min_wl=4)\n        elif case == \"lc\":\n            w = wsv.top_word(inner=pair, case=\"lc\", min_wl=4)\n        elif case == \"uc\":\n            w = wsv.top_word(inner=pair, case=\"uc\", min_wl=4)\n        if w:\n            words.append(w)\n\n    return \" \".join(words)\n\n\ndef gj_proof_ar(glyphs, mode):\n    wsv = WordSiv(vocab=\"ar\", glyphs=glyphs)\n\n    pairs = [\"\".join(pair) for pair in product(glyphs, repeat=2)]\n\n    word_list = []\n    for pair in pairs:\n        if mode == \"init\":\n            w = wsv.top_word(startswith=pair, min_wl=5)\n        elif mode == \"medi\":\n            w = wsv.top_word(inner=pair, min_wl=5)\n        elif mode == \"fina\":\n            w = wsv.top_word(endswith=pair, min_wl=5)\n        if w:\n            word_list.append(w)\n\n    return \" \".join(word_list)\n\n\nif __name__ == \"__main__\":\n    proof = \"\"\n    proof = (\n        f'English: UC-lc letter permutations at word start for glyphs \"{GLYPHS_EN}\"\\n'\n    )\n    proof += gj_proof_en(GLYPHS_EN, case=\"cap\") + \"\\n\\n\"\n\n    proof += (\n        f'English: UC-UC letter permutations inside word for glyphs \"{GLYPHS_EN}\"\\n'\n    )\n    proof += gj_proof_en(GLYPHS_EN, case=\"uc\") + \"\\n\\n\"\n\n    proof += (\n        f'English: lc-lc letter permutations inside word for glyphs \"{GLYPHS_EN}\"\\n'\n    )\n    proof += gj_proof_en(GLYPHS_EN, case=\"lc\") + \"\\n\\n\"\n\n    proof += f'Arabic: letter permutations at word start for glyphs \"{GLYPHS_AR}\"\\n'\n    proof += gj_proof_ar(GLYPHS_AR, mode=\"init\") + \"\\n\\n\"\n\n    proof += f'Arabic: letter permutations inside word for glyphs \"{GLYPHS_AR}\"\\n'\n    proof += gj_proof_ar(GLYPHS_AR, mode=\"medi\") + \"\\n\\n\"\n\n    proof += f'Arabic: letter permutations at word end for glyphs \"{GLYPHS_AR}\"\\n'\n    proof += gj_proof_ar(GLYPHS_AR, mode=\"fina\")\n\n    print(proof)\n</code></pre>"},{"location":"examples/hoefler-style-proof/","title":"Proof inspired by Jonathan Hoefler","text":"<p>If you've been proofing typefaces, you've inevitably come across Jonathan Hoefler's highly-useful English proofs. Here is a take on it that dynamically adjusts to your glyph set (<code>MY_GLYPHS</code>).</p> <pre><code>\"\"\"WordSiv proof in the style of Jonathan Hoefler.\"\"\"\n\nfrom wordsiv import WordSiv\n\nMY_GLYPHS = \"HAMBUGERFONTSIVhambugerfontsiv.,\"\n\nROUND_L_LC = \"cdeoq\"\nROUND_R_LC = \"bop\"\nFLAT_L_LC = \"bhiklmnpru\"\nFLAT_R_LC = \"dhimnqu\"\n\nFLAT_L_UC = \"BDEFHIKLMNPR\"\nFLAT_R_UC = \"HMN\"\nROUND_L_UC = \"CGOQ\"\nROUND_R_UC = \"DO\"\n\n\ndef hflr_para_lc(glyphs):\n    uc_glyphs = \"\".join(sorted(c for c in glyphs if c.isupper()))\n\n    wsv = WordSiv(vocab=\"en\", glyphs=glyphs)\n\n    common_cap = {\n        \"min_wl\": 5,\n        \"case\": \"cap\",\n        \"glyphs\": glyphs,\n    }\n    common_lc = {\"min_wl\": 5, \"case\": \"lc\", \"glyphs\": glyphs}\n\n    cap_words = []\n    for g in uc_glyphs:\n        cap_words.extend(\n            [\n                wsv.top_word(idx=0, regexp=rf\"{g}[{ROUND_L_LC}].*\", **common_cap),\n                wsv.top_word(idx=0, regexp=rf\"{g}[{FLAT_L_LC}].*\", **common_cap),\n            ]\n        )\n\n    proof = \" \".join(c for c in cap_words if c) + \".\"\n\n    for g_uc in uc_glyphs:\n        g_lc = g_uc.lower()\n        words = [\n            wsv.top_word(regexp=rf\"{g_uc}[{FLAT_L_LC}].*\", **common_cap),\n            wsv.top_word(regexp=rf\"{g_lc}[{FLAT_L_LC}].*\", **common_lc),\n            wsv.top_word(regexp=rf\"{g_lc}[{ROUND_L_LC}].*\", **common_lc),\n            wsv.word(glyphs=glyphs, top_k=20),\n            wsv.word(glyphs=glyphs, top_k=20),\n            wsv.top_word(regexp=rf\".+[{FLAT_R_LC}]{g_lc}[{FLAT_L_LC}].+\", **common_lc),\n            wsv.top_word(\n                regexp=rf\".+[{ROUND_R_LC}]{g_lc}[{ROUND_L_LC}].+\", **common_lc\n            ),\n            wsv.word(glyphs=glyphs, top_k=20),\n            wsv.word(glyphs=glyphs, top_k=20),\n            wsv.top_word(regexp=rf\".+[{FLAT_R_LC}]{g_lc}\", **common_lc),\n            wsv.top_word(regexp=rf\".+[{ROUND_R_LC}]{g_lc}\", **common_lc),\n            wsv.word(glyphs=glyphs, top_k=20),\n            wsv.top_word(\n                regexp=rf\".+[{FLAT_R_LC}]{g_lc}{g_lc}[{FLAT_L_LC}].+\", **common_lc\n            ),\n        ]\n        sent = \" \".join(w for w in words if w) + \".\"\n        proof += \" \" + sent\n\n    return proof\n\n\ndef hflr_para_uc(glyphs):\n    uc_glyphs = \"\".join(sorted(c for c in glyphs if c.isupper()))\n    wsv = WordSiv(vocab=\"en\", glyphs=glyphs)\n\n    common_uc = {\"min_wl\": 5, \"case\": \"uc\", \"glyphs\": glyphs}\n\n    uc_sents = []\n    for g in uc_glyphs:\n        words = [\n            wsv.top_word(regexp=rf\"{g}[{FLAT_L_UC}].*\", **common_uc),\n            wsv.top_word(regexp=rf\"{g}[{ROUND_L_UC}].*\", **common_uc),\n            wsv.word(glyphs=glyphs, case=\"uc\", top_k=20),\n            wsv.word(glyphs=glyphs, case=\"uc\", top_k=20),\n            wsv.top_word(regexp=rf\".+[{FLAT_R_UC}]{g}[{FLAT_L_UC}].+\", **common_uc),\n            wsv.top_word(regexp=rf\".+[{ROUND_R_UC}]{g}[{ROUND_L_UC}].+\", **common_uc),\n            wsv.word(glyphs=glyphs, case=\"uc\", top_k=20),\n            wsv.word(glyphs=glyphs, case=\"uc\", top_k=20),\n            wsv.top_word(regexp=rf\".+[{FLAT_R_UC}]{g}\", **common_uc),\n            wsv.top_word(regexp=rf\".+[{ROUND_R_UC}]{g}\", **common_uc),\n            wsv.word(glyphs=glyphs, case=\"uc\", top_k=20),\n            wsv.word(glyphs=glyphs, case=\"uc\", top_k=20),\n            wsv.top_word(regexp=rf\".+[{FLAT_R_UC}]{g}{g}[{FLAT_L_UC}].+\", **common_uc),\n        ]\n        uc_sents.append(\" \".join(w for w in words if w) + \".\")\n\n    return \" \".join(uc_sents)\n\n\nif __name__ == \"__main__\":\n    print(hflr_para_lc(MY_GLYPHS))\n    print()\n    print(hflr_para_uc(MY_GLYPHS))\n</code></pre>"},{"location":"examples/init-medi-fina-proof/","title":"Init, Medi, Fina Proof Example","text":"<p>Jos\u00e9 Sol\u00e9 modified WordSiv 0.1.0 to work with Arabic and Persian, and created a useful script to showcase letters in their <code>init</code> (start of word), <code>medi</code> (inside word), <code>fina</code> (end of word), and <code>isol</code> (by itself) forms.</p> <p>This example shows how WordSiv 0.2.0+ can support this use case:</p> <pre><code>\"\"\"WordSiv proof that is an adaption of a proof from @jmsole\"\"\"\n\nfrom wordsiv import WordSiv\n\n# Arabic and Farsi glyphs\nAR_GLYPHS = \"\u0627\u0628\u062c\u062f\u0647\u0648\u0632\u062d\u0637\u064a\u0643\u0644\u0645\u0646\u0633\u0639\u0641\u0635\u0642\u0631\u0634\u062a\u062b\u062e\u0630\u0636\u0638\u063a\u0621\"\nFA_GLYPHS = \"\u06cc\u0647\u0648\u0646\u0645\u0644\u06af\u06a9\u0642\u0641\u063a\u0639\u0638\u0637\u0636\u0635\u0634\u0633\u0698\u0632\u0631\u0630\u062f\u062e\u062d\u0686\u062c\u062b\u062a\u067e\u0628\u0627\u0621\"\n\n\ndef init_medi_fina(glyphs, lang):\n    wsv = WordSiv(glyphs=glyphs, vocab=lang)\n\n    lines = []\n    for g in glyphs:\n        init = \" \".join(wsv.top_words(n_words=5, min_wl=5, max_wl=14, startswith=g))\n        medi = \" \".join(wsv.top_words(n_words=5, min_wl=5, max_wl=14, inner=g))\n        fina = \" \".join(wsv.top_words(n_words=5, min_wl=5, max_wl=14, endswith=g))\n        lines.append(g + \" \" + \" \".join([init, medi, fina]))\n\n    return \"\\n\".join(lines)\n\n\nif __name__ == \"__main__\":\n    # Generate and print text proofs for Arabic and Farsi templates\n    print(\"Proof text in Farsi:\")\n    print(init_medi_fina(FA_GLYPHS, lang=\"fa\"))\n\n    print(\"Proof text in Arabic:\")\n    print(init_medi_fina(AR_GLYPHS, lang=\"ar\"))\n</code></pre>"},{"location":"examples/quick-reference/","title":"Quick Reference","text":"<p>Install WordSiv in DrawBot, and try out this script to get an idea of the kinds of things WordSiv can do:</p> <pre><code>from wordsiv import WordSiv\n\n# initialize WordSiv, using Vocab \"en\" (English), and restricting glyphs to\n# MY_GLYPHS. Setting the optional seed means our output will be reproducible\nMY_GLYPHS = \"HAMBUGERFONTSIVhambugerfontsiv.,\"\nwsv = WordSiv(vocab=\"en\", glyphs=MY_GLYPHS, seed=123)\n\n# See what other vocabs are available:\nprint(wsv.list_vocabs())\n\n# Sample any word using probabilities:\nprint(wsv.word())\n\n# Sample a totally random word that starts with \"B\", contains \"a\", ends with \"rs\"\nprint(wsv.word(rnd=1, startswith=\"B\", contains=\"a\", endswith=\"rs\"))\n\n# Most common word which has an inner \"aa\" (not overlapping first or last\n# letter) and at least 6 letters\nprint(wsv.top_word(inner=\"aa\", min_wl=6))\n\n# A list of 7 totally random all caps words (including lowercase, capitalized\n# words made all caps) that are 7 letters long\nprint(wsv.words(n_words=7, wl=7, rnd=1, case=\"uc\"))\n\n# Sample 5 totally random all caps words from the Vocab which are already all\n# caps (useful for getting acronyms and similar)\nprint(wsv.words(n_words=5, rnd=1, case=\"uc_og\"))\n\n# List of top 5 lowercase words which are at least 15 letters long\nprint(wsv.top_words(n_words=5, min_wl=15, case=\"lc\"))\n\n# Top 5 Spanish words of 5 or less letters, which have an inner \"\u00ed\", made\n# capitalized\nES_GLYPHS = \"HAMBUGERFONTSIVhambugerfontsiv.,\u00e9\u00e1\u00ed\"\nprint(\n    wsv.top_words(\n        vocab=\"es\", glyphs=ES_GLYPHS, inner=\"\u00ed\", n_words=5, max_wl=5, case=\"cap\"\n    )\n)\n\nprint(wsv.top_words(n_words=5, startswith=\"sh\", regexp=r\"(?!.*[aot].*).*\"))\n\n# A sentence from word probabilities, adding a little bit of randomness\nprint(wsv.sent(rnd=0.03))\n\n# A sentence in arabic with 7-10 words, drawing from only the top 100 words in\n# the Vocab. We are choosing not to restrict the glyphs on this WordSiv\n# instance!\nwsv_ar = WordSiv(vocab=\"ar\", seed=123)\nprint(wsv_ar.sent(min_n_words=7, max_n_words=10, top_k=100))\n\n# A sentence that isn't capitalized\nprint(wsv.sent(cap_first=False))\n\n# A list of 3 sentences, with 20% chance of random figures:\nprint(wsv.sents(glyphs=MY_GLYPHS + \"0123456789\", n_sents=3, numbers=0.2))\n\n# A paragraph:\nprint(wsv.para())\n\n# A paragraph w/ no punctuation:\nprint(wsv.para(punc=False))\n\n# A paragraph w/ totally random punctuation (not based on probabilities):\nprint(wsv.para(glyphs=MY_GLYPHS + \"!?;()-\u2013\u2014\u201c\u201d\u2018\u2019\", rnd_punc=1))\n\n# A paragraph in Farsi with 2-3 sentences:\nprint(\n    wsv.para(\n        vocab=\"fa\",\n        glyphs=\".\u060c\u0623\u0628\u062a\u062b\u062c\u062d\u062e\u062f\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u064a\",\n        min_n_sents=2,\n        max_n_sents=3,\n    )\n)\n\n# A list of 2 Paragraphs:\nprint(wsv.paras(n_paras=2))\n\n# Block of text:\nprint(wsv.text())\n\n# Block of text w/\n# - 3 paragraphs, 2-3 sentences a paragraph, 3-5 words a sentence\n# - paragraphs separated by \"\u00b6\":\n# - roughly 10% figures, 10% chance of random words\n# - 50% totally random punctuation distribution\nprint(\n    wsv.text(\n        glyphs=MY_GLYPHS + \"0123\u00b6-\u2013\u2014\u201c\u201d\u2018\u2019();!?\",\n        numbers=0.1,\n        rnd=0.1,\n        rnd_punc=0.5,\n        min_n_words=3,\n        max_n_words=5,\n        min_n_sents=2,\n        max_n_sents=3,\n        n_paras=3,\n        para_sep=\"\u00b6\",\n    )\n)\n</code></pre>"},{"location":"usage/basic-usage/","title":"Basic Usage","text":""},{"location":"usage/basic-usage/#importing-and-initializing-wordsiv","title":"Importing and initializing WordSiv","text":"<p>Once you've installed WordSiv, try generating a sentence: <pre><code>from wordsiv import WordSiv\n\n# Make a WordSiv object, w/ default Vocab set to English\nwsv = WordSiv(vocab=\"en\")\n\n# Generate a sentence w/out any word filtering\nprint(wsv.sent())\n</code></pre></p> <p>You should see a random sentence in the console in the lower-right of DrawBot!</p> <p>Check out the Quick Reference if you want to quickly jump into WordSiv, or read on for more detailed information.</p>"},{"location":"usage/basic-usage/#listing-vocabs","title":"Listing Vocabs","text":"<p>WordSiv generates text using Vocabs: objects that contain a word list (usually with occurrence counts) for a given language. WordSiv includes some Vocabs, and you can make your own (instructions coming soon!). You can see all available Vocabs with: <code>list_vocabs()</code>:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv()\nprint(wsv.list_vocabs())\n</code></pre>"},{"location":"usage/basic-usage/#selecting-a-vocab","title":"Selecting a Vocab","text":"<p>You can set which Vocab you want to use on <code>WordSiv</code> object initialization, which will affect all text generation methods you call: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"ar\")\nprint(wsv.para())\n</code></pre></p> <p>Alternatively, you can specify <code>vocab</code> when you are calling <code>word()</code>, <code>sent()</code>, etc.: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv()\nprint(wsv.para(vocab=\"en\"))\n</code></pre></p> <p>Note</p> <p>The <code>vocab</code> argument for <code>word()</code>, <code>sent()</code>, etc. has precedence: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# paragraph in English\nprint(wsv.para())\n# paragraph in Spanish\nprint(wsv.para(vocab=\"es\"))\n</code></pre></p>"},{"location":"usage/basic-usage/#restricting-the-glyph-set","title":"Restricting the Glyph Set","text":"<p>The <code>glyphs</code> argument specifies a whitelist of glyphs that WordSiv will use to constrain text generation.</p> <p>You can set <code>glyphs</code> on <code>WordSiv</code> object initialization, which will affect all subsequent text generation methods you call: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERFONTShambugerfonts.,\")\nprint(wsv.words())\n</code></pre></p> <p>Alternatively, you can specify <code>glyphs</code> when you are calling <code>word()</code>, <code>sent()</code>, etc.: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\nprint(wsv.words(glyphs=\"hambugerfonts.,\"))\n</code></pre></p> <p>Note</p> <p>The <code>glyphs</code> argument for <code>word()</code>, <code>sent()</code>, etc. has precedence: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERFONTShambugerfonts.,\")\n\n# uses glyphs \"HAMBUGERFONTShambugerfonts.,\"\nprint(wsv.words())\n# uses glyphs \"hambugerfonts.,\"\"\nprint(wsv.words(glyphs=\"hambugerfonts.,\"))\n</code></pre></p>"},{"location":"usage/filtering-words/","title":"Filtering Words","text":"<p>WordSiv provides options for filtering the words that are used to generate text:</p> <ul> <li>Letter Case: <code>case</code></li> <li>Word Length: <code>wl</code>, <code>min_wl</code>, <code>max_wl</code></li> <li>Substrings: <code>startswith</code>, <code>endswith</code>, <code>contains</code>, <code>inner</code></li> <li>Regular Expressions: <code>regexp</code></li> </ul> <p>We demonstrate these arguments with <code>top_words()</code> so you can see what's happening without randomization. You can use these arguments for <code>word()</code>, <code>words()</code>, <code>top_word()</code>, <code>top_words()</code>, <code>sent()</code>, <code>sents()</code>, <code>para()</code>, <code>paras()</code>, <code>text()</code>.</p>"},{"location":"usage/filtering-words/#filter-words-by-letter-case","title":"Filter Words by Letter Case","text":"<p>The most important parameter in WordSiv (for bicameral languages) is <code>case</code>. WordSiv allows for words in Vocabs to be:</p> <ul> <li>lowercase (e.g. <code>\"owl\"</code>): <code>lc</code></li> <li>capitalized (e.g. <code>\"Korea\"</code>): <code>cap</code></li> <li>all caps (e.g. <code>\"WWF\"</code>): <code>uc</code></li> <li>camel-case (e.g. <code>\"DDoS\"</code>): (no parameter, but respected)</li> </ul> <p>The <code>case</code> argument allows you to select the desired letter case while considering your available glyphs (if you've set <code>glyphs</code>), optionally transforming the original case of words from the Vocab to expand results.</p> <p>The options are best demonstrated with a small example Vocab: <pre><code>from wordsiv import Vocab, WordSiv\n\n# Make example Vocab w/ no probabilities\nexample_words = \"grape\\nApril\\nBART\\nDDoS\"\nvocab = Vocab(bicameral=True, lang=\"en\", data=example_words)\n\n# Build our WordSiv object\nwsv = WordSiv(add_default_vocabs=False)\nwsv.add_vocab(\"example\", vocab)\nwsv.vocab = \"example\"\n\n# Select words that *already have* desired case in the Vocab\nassert wsv.top_word(case=\"lc\") == \"grape\"\nassert wsv.top_word(case=\"cap_og\") == \"April\"\nassert wsv.top_word(case=\"uc_og\") == \"BART\"\nassert wsv.top_words(case=\"any_og\") == [\"grape\", \"April\", \"BART\", \"DDoS\"]\n\n# Select words that *can be transformed* to desired case\nassert wsv.top_words(case=\"cap\") == [\"Grape\", \"April\"]\nassert wsv.top_words(case=\"uc\") == [\"GRAPE\", \"APRIL\", \"BART\"]\n\n# Select all words and transform to desired case\nassert wsv.top_words(case=\"cap_force\") == [\"Grape\", \"April\", \"Bart\", \"Ddos\"]\nassert wsv.top_words(case=\"uc_force\") == [\"GRAPE\", \"APRIL\", \"BART\", \"DDOS\"]\n\n# Special 'any' case tries 'any_og', then tries 'cap' and 'uc' if no results\n# Notice we left out the 'case' parameter on the second call, since 'any' is the default\nassert wsv.top_word(glyphs=\"Grape\", case=\"any\") == \"Grape\"\nassert wsv.top_word(glyphs=\"APRIL\") == \"APRIL\"\n</code></pre></p>"},{"location":"usage/filtering-words/#default-smart-any-case-caseany","title":"Default: Smart Any Case (<code>case='any'</code>)","text":"<p>The default option (<code>case='any'</code>) tries to match as many words as possible, first trying <code>any_og</code>, then <code>cap</code>, then <code>uc</code> if there are not any matches.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n#   Returns 'ZOO' as most common word\nprint(wsv.top_word(glyphs=\"ZO\", min_wl=5))\n\n# No `case` arg, so the default is `case='any'` which will:\n# - try to get (unmodified) words from Vocab which can be spelled with \"ZO\"\n#   (that have at least 3 characters): No results.\n# - try to capitalize Vocab words: \"zoo\" becomes \"Zoo\" but we can't spell it\n#   without 'o'. No results.\n# - try to uppercase Vocab words: \"zoo\" becomes \"ZOO\", which we can spell!\n</code></pre>"},{"location":"usage/filtering-words/#any-case-caseany_og","title":"Any Case (<code>case='any_og'</code>)","text":"<p>The <code>any_og</code> option selects any word from the Vocab that can be spelled with <code>glyphs</code> (if set, otherwise all words). It does not change the case of words from the vocab.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# We don't get any words, because there are no words of at least 5 letters in\n# our Vocab that \"AIPRS\" can spell\nprint(wsv.top_word(glyphs=\"AIPRS\", case=\"any_og\", min_wl=5))\n\n# However, this returns \"Paris\" since we have all the glyphs\nprint(wsv.top_word(glyphs=\"aiPrs\", case=\"any_og\", min_wl=5))\n</code></pre>"},{"location":"usage/filtering-words/#lowercase-caselc","title":"Lowercase (<code>case='lc'</code>)","text":"<p>The <code>lc</code> option selects lowercase words from the Vocab (e.g. <code>\"bread\"</code>). It will not try to lowercase any words with capitals, since we wouldn't want to lowercase words like <code>\"Paris\"</code>, <code>\"FAA\"</code>, or <code>\"DDoS\"</code></p> <p>Why no <code>lc_og</code>?</p> <p>There is no need for a <code>lc_og</code> option, because <code>lc</code> already only selects lowercase words from the Vocab.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"lc\"))\n</code></pre>"},{"location":"usage/filtering-words/#forced-lowercase-caselc_force","title":"Forced Lowercase (<code>case='lc_force'</code>)","text":"<p>The <code>lc_force</code> option selects all words from the Vocab, and indiscriminately transforms them to lowercase.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"lc_force\"))\n</code></pre>"},{"location":"usage/filtering-words/#capitalized-casecap","title":"Capitalized (<code>case='cap'</code>)","text":"<p>The <code>cap</code> option selects capitalized words from the Vocab (e.g. <code>\"Paris\"</code>) as well as lowercase (e.g. <code>\"boat\"</code>) words from the Vocab, capitalizing them (e.g. <code>\"Paris\", \"Boat\"</code>).</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"cap\"))\n</code></pre>"},{"location":"usage/filtering-words/#capitalized-no-case-change-casecap_og","title":"Capitalized, No Case Change  (<code>case='cap_og'</code>)","text":"<p>The <code>cap_og</code> option selects capitalized words from the Vocab (like <code>\"Paris\"</code>). It does not capitalize any lowercase words (like <code>case='cap'</code> does). This is useful for getting capitalized words like proper nouns.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"cap_og\"))\n</code></pre>"},{"location":"usage/filtering-words/#forced-capitalized-casecap_force","title":"Forced Capitalized (<code>case='cap_force'</code>)","text":"<p>The <code>cap_force</code> option selects all words from the Vocab, and indiscriminately transforms them to uppercase.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"cap_force\"))\n</code></pre>"},{"location":"usage/filtering-words/#all-caps-caseuc","title":"All Caps (<code>case='uc'</code>)","text":"<p>The <code>uc</code> option selects all caps words from the Vocab (e.g. <code>\"WWF\"</code>), as well as lowercase (e.g. <code>\"boat\"</code>) and capitalized (e.g. <code>\"Paris\"</code>) words from the vocab, transforming them to all caps (e.g. <code>\"WWF\", \"BOAT\", \"PARIS\"</code>).</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"uc\"))\n</code></pre>"},{"location":"usage/filtering-words/#all-caps-no-case-change-caseuc_og","title":"All Caps, No Case Change (<code>case='uc_og'</code>)","text":"<p>The <code>uc_og</code> option selects all caps words from the Vocab (e.g. <code>\"WWF\"</code>). It does not capitalize any lowercase or capitalized words (like <code>case='uc'</code> does). This is useful for getting all caps words like acronyms.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"uc_og\"))\n</code></pre>"},{"location":"usage/filtering-words/#forced-all-caps-caseuc_force","title":"Forced All Caps (<code>case='uc_force'</code>)","text":"<p>The <code>uc_force</code> option selects all words from the Vocab, and indiscriminately transforms them to uppercase.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERShambugers\")\nprint(wsv.top_word(case=\"uc_force\"))\n</code></pre>"},{"location":"usage/filtering-words/#filter-words-by-word-length","title":"Filter Words by Word Length","text":"<p>Arguments <code>wl</code>, <code>min_wl</code>, and <code>max_wl</code> let you select for the length of words in the Vocab:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Exactly 7 letters\nprint(wsv.top_word(wl=7))\n\n# At least 4 letters\nprint(wsv.top_word(min_wl=4))\n\n# No more than 20 letters\nprint(wsv.top_word(max_wl=20))\n\n# At least 10 letters, no more than 20 letters\nprint(wsv.top_word(min_wl=10, max_wl=20))\n</code></pre>"},{"location":"usage/filtering-words/#filter-words-by-substrings","title":"Filter Words by Substrings","text":"<p>Arguments <code>startswith</code>, <code>endswith</code>, <code>contains</code>, and <code>inner</code> let you select words which contain specific substrings.</p>"},{"location":"usage/filtering-words/#word-starts-with-string-startswith","title":"Word Starts With String (<code>startswith</code>)","text":"<p>Argument <code>startswith</code> matches words that have a specific glyph/string at the start of the word, after any case transformations may have occurred.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# starts with single glyph\nprint(wsv.top_word(startswith=\"v\"))\n\n# starts with string\nprint(wsv.top_word(startswith=\"ev\"))\n</code></pre>"},{"location":"usage/filtering-words/#word-ends-with-string-endswith","title":"Word Ends With String (<code>endswith</code>)","text":"<p>Argument <code>endswith</code> matches words that have a specific glyph/string at the end of the word, after any case transformations may have occurred.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# contains single glyph\nprint(wsv.top_word(endswith=\"s\"))\n# contains string\nprint(wsv.top_word(endswith=\"ats\"))\n</code></pre>"},{"location":"usage/filtering-words/#word-contains-strings-contains","title":"Word Contains String(s) (<code>contains</code>)","text":"<p>Argument <code>contains</code> matches words which contain specific string(s) in the word, after any case transformations may have occurred.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# contains single glyph\nprint(wsv.top_word(contains=\"a\"))\n# contains string\nprint(wsv.top_word(contains=\"orr\"))\n\n# contains multiple glyphs/strings\n# `inner` only accepts a tuple, not a list (this is for caching)\nprint(wsv.top_word(contains=(\"b\", \"rr\")))\n</code></pre>"},{"location":"usage/filtering-words/#word-contains-inner-strings-inner","title":"Word Contains Inner String(s) (<code>inner</code>)","text":"<p>Argument <code>inner</code> matches words which contain specific string(s) in <code>word[1:-1]</code> (all but first and last glyphs), after any case transformations may have occurred.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Contains glyph inside (word[1:-1])\nprint(wsv.top_word(inner=\"b\"))\n# Contains string inside (word[1:-1])\nprint(wsv.top_word(inner=\"br\"))\n\n# Contains multiple strings inside (word[1:-1])\n# `inner` only accepts a tuple, not a list (this is for caching)\nprint(wsv.top_word(inner=(\"br\", \"ck\")))\n</code></pre>"},{"location":"usage/filtering-words/#filter-words-by-regex","title":"Filter Words by Regex","text":"<p>The <code>regexp</code> argument lets you match words by regular expression. This filter happens after any case transformations may have occurred. It uses the regex library from PyPI which gives more options for selecting unicode blocks and more:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\nprint(wsv.top_word(regexp=r\"h.+b.*ger\"))\n\n# WordSiv uses regex (third-party) regex library from PyPi,\n# so you can specify Unicode blocks like this:\nwsv_es = WordSiv(vocab=\"es\")\nprint(wsv_es.top_words(regexp=r\".*\\p{InLatin-1_Supplement}.*\"))\n\n# See https://www.regular-expressions.info/unicode.html for\n# more examples of \\p{...} syntax\n</code></pre>"},{"location":"usage/filtering-words/#debugging-filters-and-raising-errors","title":"Debugging Filters and Raising Errors","text":"<p>Most of the time when proofing, some output is better than nothing. When WordSiv can't find a matching word for your <code>glyphs</code> and filter arguments, it will just return an empty string and send a warning log message to the console with some details. However, we can change these behaviors:</p>"},{"location":"usage/filtering-words/#suppressing-warning-messages","title":"Suppressing Warning Messages","text":"<p>WordSiv by default outputs log messages when there are no matching words for the given filters. However, you can turn this off by adjusting the log level:</p> <pre><code>from wordsiv import WordSiv\nimport logging\n\n# Initially we'll set the logger to show WARNING and more severe\nlog = logging.getLogger(\"wordsiv\")\nlog.setLevel(logging.WARNING)\n\nwsv = WordSiv(vocab=\"en\")\n\n# We see a warning in our console\nprint(wsv.top_word(contains=\"BLAH\"))\n\n# We can suppress these warnings by setting the logging level to ERROR:\nlog.setLevel(logging.ERROR)\n\n# No warning this time!\nprint(wsv.top_word(contains=\"NOWAY\"))\n</code></pre>"},{"location":"usage/filtering-words/#raising-errors","title":"Raising Errors","text":"<p>Maybe you want your script to halt if there are no matching words, or want to catch the error and try something else. For this you can use the <code>raise_errors</code> option, which will raise <code>wordsiv.FilterError</code> if there are no word matches.</p> <pre><code>from wordsiv import WordSiv, FilterError\n\nwsv = WordSiv(vocab=\"en\", raise_errors=True)\n\ntry:\n    wsv.top_word(contains=\"NOWAY\")\nexcept FilterError as e:\n    print(f'We can handle our error \"{e}\" here!')\n</code></pre>"},{"location":"usage/generating-text/","title":"Generating Text","text":"<p>WordSiv provides several methods for generating text:</p> <ul> <li>Word(s): <code>word()</code>,   <code>words()</code>,   <code>top_word()</code>,   <code>top_words()</code></li> <li>Sentence(s): <code>sent()</code>, <code>sents()</code></li> <li>Paragraph(s): <code>para()</code>,   <code>paras()</code></li> <li>Text Block: <code>text()</code></li> </ul> <p>For methods that generate text with probabilities (not <code>top_word()</code>, <code>top_words()</code>), there are options for adjusting the randomness of the output:</p> <ul> <li><code>seed</code>: Make output repeatable (deterministic)</li> <li><code>rnd</code>: Blend in fully random word selection with   probability-based word selection</li> <li><code>rnd_punc</code>: Blend in fully random   punctuation selection with the default probability-based punctuation selection</li> </ul> <p>There are also additional options:</p> <ul> <li><code>numbers</code>: Mix-in figures with the words</li> <li><code>punc</code>: Optionally disable punctuation</li> <li><code>top_k</code>: Restrict the word list used for text generation to <code>top_k</code> (most probable) words</li> </ul>"},{"location":"usage/generating-text/#text-generation-methods","title":"Text Generation Methods","text":"<p>WordSiv is structured so that word generation calls cascade, passing arguments from the larger to smaller text generation methods. So when you call <code>text()</code>, you get this chain of method calls:</p> <p><code>text()</code> \u2794 <code>paras()</code> \u2794 <code>para()</code> \u2794 <code>sents()</code> \u2794 <code>sent()</code> \u2794 <code>words()</code> \u2794 <code>word()</code></p> <p>This means you can pass arguments to <code>text()</code> that will effect all the smaller text generation methods it calls:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\nprint(\n    wsv.text(\n        n_paras=3,  # number of paragraphs\n        min_n_sents=2,  # min sentences per paragraph\n        max_n_sents=4,  # max sentences per paragraph\n        min_n_words=3,  # min words per sentence\n        max_n_words=7,  # max words per sentence\n        numbers=0.1,  # 10% chance of numbers\n        rnd=0.1,  # 10% random word selection\n        rnd_punc=0.5,  # 50% random punctuation\n        para_sep=\"\u00b6\",  # custom paragraph separator\n        min_wl=5,  # minimum word length\n        max_wl=10,  # maximum word length\n        contains=\"a\",  # words contains substring (doesn't affect numbers)\n    )\n)\n</code></pre>"},{"location":"usage/generating-text/#random-word-word","title":"Random Word (<code>word()</code>)","text":"<p>The <code>word()</code> method returns a single word, randomly selected from the Vocab (weighted by word probability). See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# random single word from probabilities\nprint(wsv.word())\n\n# random single word with glyphs restriction\nprint(wsv.word(glyphs=\"HAMBUGERFONTSIVhambugerfontsiv\"))\n\n# random single word, no probablities\nprint(wsv.word(rnd=1))\n</code></pre>"},{"location":"usage/generating-text/#most-common-word-top_word","title":"Most Common Word (<code>top_word()</code>)","text":"<p>The <code>top_word()</code> method returns the most common word or the nth common word. See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Get most common word\nprint(wsv.top_word())\n\n# Get 5th most common word\nprint(wsv.top_word(idx=4))\n\n# Get 5th most common word after word filters\nprint(wsv.top_word(idx=4, glyphs=\"HAMBUGERFONTSIVhambugerfontsiv\", wl=7))\n</code></pre>"},{"location":"usage/generating-text/#list-of-random-words-words","title":"List of Random Words (<code>words()</code>)","text":"<p>The <code>words()</code> method returns a list of words generated by <code>word()</code> (randomly selected from the Vocab, weighted by word probability). See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Random number of words\nprint(wsv.words())\n\n# Random number of words, capitalized first word\nprint(wsv.words(cap_first=True))\n\n# 5 words\nprint(wsv.words(n_words=5))\n\n# 3-10 words\nprint(wsv.words(min_n_words=3, max_n_words=10))\n\n# 10 numbers\nprint(wsv.words(numbers=1, n_words=10))\n\n# 50% words, 50% numbers\nprint(wsv.words(numbers=0.5, n_words=10))\n</code></pre>"},{"location":"usage/generating-text/#list-of-most-common-words-top_words","title":"List of Most Common Words (<code>top_words()</code>)","text":"<p>The <code>top_words()</code> method returns a list of the most common words in descending frequency order. See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Get 10 most common words\nprint(wsv.top_words(n_words=10))\n\n# Get the 10th-19th most common words\nprint(wsv.top_words(n_words=10, idx=9))\n\n# Get 10 most common words after word filters\nprint(wsv.top_words(n_words=10, glyphs=\"HAMBUGERFONTSIVhambugerfontsiv\", wl=7))\n</code></pre>"},{"location":"usage/generating-text/#sentence-sent","title":"Sentence (<code>sent()</code>)","text":"<p>The <code>sent()</code> method returns a single sentence, joining the output of <code>words()</code> with punctuation (optionally). See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Sentence of random length\nprint(wsv.sent())\n\n# Sentence w/ no punctuation\nprint(wsv.sent(punc=False))\n\n# Sentence w/ 5 words and completely random punctuation\nprint(wsv.sent(rnd_punc=1, n_words=5))\n\n# Sentence w/ 3-10 words\nprint(wsv.sent(min_n_words=3, max_n_words=10))\n\n# String of 10 numbers\nprint(wsv.sent(numbers=1, n_words=10))\n\n# 50% words, 50% numbers\nprint(wsv.sent(numbers=0.5, n_words=10))\n</code></pre>"},{"location":"usage/generating-text/#list-of-sentences-sents","title":"List of Sentences (<code>sents()</code>)","text":"<p>The <code>sents()</code> method returns a list of sentences generated from <code>sent()</code>. See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# A random number of sentences\nprint(wsv.sents())\n\n# 5 sentences\nprint(wsv.sents(n_sents=5))\n\n# 2-3 sentences\nprint(wsv.sents(min_n_sents=2, max_n_sents=3))\n</code></pre>"},{"location":"usage/generating-text/#paragraph-para","title":"Paragraph (<code>para()</code>)","text":"<p>The <code>para()</code> method returns a single paragraph, joining the output of <code>sents()</code>. See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Paragraph w/ random number of sentences\nprint(wsv.para())\n\n# Paragraph w/ 3 sentences\nprint(wsv.para(n_sents=3))\n\n# Paragraph which joins sentences with a custom separator\nprint(wsv.para(sent_sep=\"\\n\"))\n\n# Paragraph w/ 1-3 sentences\nprint(wsv.para(min_n_sents=1, max_n_sents=3))\n</code></pre>"},{"location":"usage/generating-text/#multiple-paragraphs-paras","title":"Multiple Paragraphs (<code>paras()</code>)","text":"<p>The <code>paras()</code> method returns a list of paragraphs generated from <code>para()</code>. See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Random number of paragraphs\nprint(wsv.paras())\n\n# 3 paragraphs\nprint(wsv.paras(n_paras=3))\n</code></pre>"},{"location":"usage/generating-text/#text-block-text","title":"Text Block (<code>text()</code>)","text":"<p>The <code>text()</code> method generates a text block, joining the output of <code>paras()</code>. See also word filter arguments.</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Text block w/ random number of paragraphs\nprint(wsv.text())\n\n# Text block with special paragraph separator\nprint(wsv.text(para_sep=\"\u00b6\"))\n\n# Text block w/ 3 paragraphs\nprint(wsv.text(n_paras=3))\n</code></pre>"},{"location":"usage/generating-text/#adjusting-randomness","title":"Adjusting Randomness","text":""},{"location":"usage/generating-text/#repeatable-output-seed","title":"Repeatable Output (<code>seed</code>)","text":"<p>For reproducible results, you can set a random seed when initializing WordSiv or for individual function calls. This is essential if you want your proof to remain the same until you make changes to the code (or your glyphs).</p> <pre><code>from wordsiv import WordSiv\n\n# Set seed on initialization\nwsv = WordSiv(vocab=\"en\", seed=123)\nprint(wsv.words(n_words=5))\n\n# Or set seed for specific calls\nwsv = WordSiv(vocab=\"en\")\nprint(wsv.words(n_words=5, seed=123))\n</code></pre> <p>This example might give you a better example of how this works: <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERFONThambugerfont\")\n\n# same results\nprint(wsv.sent(seed=3))\n# \"Heart tent terra Emma root buffet foam mom Hagen to earth at ammo\"\nprint(wsv.sent(seed=3))\n# \"Heart tent terra Emma root buffet foam mom Hagen to earth at ammo\"\n\n# not if we change our glyphs though!\nwsv.glyphs = \"HAMBUGERFONTSIVhambugerfontsiv\"\nprint(wsv.sent(seed=3))\n# \"Of not but not to as on to setting the of the things\"\n\n# you only need to seed at the beginning of your proof:\nwsv.seed(1)\nprint(wsv.word())\n# \"of\"\nprint(wsv.word())\n# \"agreement\"\n\n# See? same results as above:\nwsv.seed(1)\nprint(wsv.word())\n# \"of\"\nprint(wsv.word())\n# \"agreement\"\n\n# so as long as you don't insert a new call which uses the random generator in-between:\nwsv.seed(1)\nprint(wsv.word())\n# \"of\"\nprint(wsv.word(startswith=\"f\"))\n# \"fee\"\nprint(wsv.word())\n# \"area\"\n</code></pre></p>"},{"location":"usage/generating-text/#word-randomness-rnd","title":"Word Randomness (<code>rnd</code>)","text":"<p>The <code>rnd</code> parameter controls how random the word generation is. This is useful for outputting more less-probable words, especially when your glyph set is limited (the probability distribution becomes even more skewed towards short, common words).</p> <ul> <li><code>rnd=0</code>: Use word probabilities to select words (default)</li> <li><code>rnd=1</code>: Completely random word selection</li> <li><code>0&lt;rnd&lt;1</code>: Interpolation of word probability distribution and fully random   distribution</li> </ul> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\", glyphs=\"HAMBUGERFONTSIVhambugerfontsiv\")\n\n# Default behavior - based on word frequencies\nprint(wsv.words(n_words=10))\n\n# Completely random selection\nprint(wsv.words(n_words=10, rnd=1))\n\n# Blending in just a little bit of randomness helps when you have a very constricted\n# glyphs set like \"HAMBUGERFONTS\"\nprint(wsv.words(n_words=10, rnd=0.03))\n</code></pre>"},{"location":"usage/generating-text/#punctuation-randomness-rnd_punc","title":"Punctuation Randomness (<code>rnd_punc</code>)","text":"<p>The <code>rnd_punc</code> parameter controls how random the punctuation generation is. This is useful for getting less common punctuation that statistically doesn't occur all that often.</p> <ul> <li><code>rnd_punc=0</code>: Use punctuation frequencies to select punctuation (default)</li> <li><code>rnd_punc=1</code>: Completely random punctuation selection</li> <li><code>0&lt;rnd_punc&lt;1</code>: Interpolation of punctuation frequency distribution and fully   random distribution</li> </ul> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Default behavior - based on punctuation probabilities\nprint(wsv.sent(rnd_punc=0))\n\n# Completely random punctuation selection\nprint(wsv.sent(rnd_punc=1))\n\n# Interpolation between totally random punc selection and probability-based punc\n# selection\nprint(wsv.sent(rnd_punc=0.5))\n</code></pre>"},{"location":"usage/generating-text/#additional-options","title":"Additional Options","text":""},{"location":"usage/generating-text/#limiting-word-pool-top_k","title":"Limiting Word Pool (<code>top_k</code>)","text":"<p>You can restrict word selection to the most common <code>top_k</code> words. This is useful if you want to generate text with only highly-frequent words:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# Top 100 most frequent words\nprint(wsv.text(top_k=100))\n\n# This is useful to get a selection of highly-frequent words, without skewing towards\n# the top few words.\nprint(wsv.text(rnd=1, top_k=1000))\n</code></pre>"},{"location":"usage/generating-text/#mixing-in-numbers-numbers","title":"Mixing In Numbers (<code>numbers</code>)","text":"<p>You can include basic random figures in your text (constrained by <code>glyphs</code>) with the <code>numbers</code> parameter:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# No numbers (default is 0 anyway)\nprint(wsv.sent(numbers=0))\n\n# 25% chance each word is a number (will make up roughly 25% of text)\nprint(wsv.text(numbers=0.25))\n\n# A list of numbers\nprint(wsv.words(numbers=1))\n</code></pre>"},{"location":"usage/generating-text/#disabling-punctuation-punc","title":"Disabling Punctuation (<code>punc</code>)","text":"<p>You can disable punctuation with the <code>punc</code> parameter:</p> <pre><code>from wordsiv import WordSiv\n\nwsv = WordSiv(vocab=\"en\")\n\n# No punctuation\nprint(wsv.para(punc=False))\n</code></pre>"},{"location":"usage/language-support/","title":"Language Support","text":""},{"location":"usage/language-support/#vocab","title":"Vocab","text":"<p>In WordSiv, a Vocab is an object that contains a word list and other language-specific data that allow a WordSiv object to appropriately filter words and generate text.</p> <p>Note</p> <p>I considered naming this object WordList, but it also can contain word counts and punctuation data. I considered calling it Lang, but it's possible to have more than one set of words (and punctuation, etc.) per language. I can imagine having Vocabs derived from different genres of text: <code>en-news</code>, <code>en-wiki</code>, etc!</p>"},{"location":"usage/language-support/#using-a-built-in-vocab","title":"Using a Built-in Vocab","text":"<p>See Basic Usage for how to list and select a built-in Vocab. If you're curious about the origin/license<sup>1</sup> of these lists you can examine the built-in Vocabs in wordsiv/_vocab_data.</p>"},{"location":"usage/language-support/#creating-a-custom-vocab","title":"Creating a custom Vocab","text":"<p>It's easy to add your own Vocab to WordSiv. The harder part is actually deriving wordlists from a text corpus) and refining the capitalization (if applicable), which we won't detail here.</p> <p>Let's say we grab the top 20 German words from this frequency wordlist derived from OpenSubtitles, and save it as <code>de-words.tsv</code> (replacing spaces with tabs): <pre><code>ich 3699605\nsie 2409949\ndas 1952794\nist 1920535\ndu  1890181\nnicht   1734016\ndie 1585020\nes  1460530\nund 1441012\nder 1109693\nwir 1075801\nwas 1072372\nzu  918548\ner  851812\nein 841835\nin  793011\nmir 645137\nmit 641744\nja  635186\nden 588653\n</code></pre></p> <p>We can now create a Vocab and add it to WordSiv: <pre><code>from wordsiv import Vocab, WordSiv\n\n# Create a Vocab from a file\nde_vocab = Vocab(lang=\"de\", data_file=\"de.tsv\", bicameral=True)\n\n# Add Vocab to WordSiv object\nws = WordSiv()\nws.add_vocab(\"de-subtitles\", de_vocab)\n\n# Try it out\nprint(ws.sent(vocab=\"de-subtitles\"))\n</code></pre></p> <p>We get the output:</p> <p>Die du die der ich nicht sie das und e</p>"},{"location":"usage/language-support/#adding-custom-punctuation-to-a-vocab","title":"Adding Custom Punctuation to a Vocab","text":"<p>But what if we want punctuation? We have some default punctuation for the built-in languages in wordsiv/_punctuation.py, but not yet for German (at the time of writing). Let's copy/paste the English one (for now<sup>2</sup>) and try it out: <pre><code>from wordsiv import Vocab, WordSiv\n\n# Define the punctuation dictionary\nde_punc = {\n    \"insert\": {\n        \" \": 0.365,\n        \", \": 0.403,\n        \": \": 0.088,\n        \"; \": 0.058,\n        \"\u2013\": 0.057,\n        \"\u2014\": 0.022,\n        \" \u2026 \": 0.006,\n    },\n    \"wrap_sent\": {\n        (\"\", \".\"): 0.923,\n        (\"\", \"!\"): 0.034,\n        (\"\", \"?\"): 0.04,\n        (\"\", \"\u2026\"): 0.003,\n    },\n    \"wrap_inner\": {\n        (\"\", \"\"): 0.825,\n        (\"(\", \")\"): 0.133,\n        (\"\u2018\", \"\u2019\"): 0.013,\n        (\"\u201c\", \"\u201d\"): 0.028,\n    },\n}\n\n# Create a Vocab from a file, this time passing punctuation\nde_vocab = Vocab(lang=\"de\", data_file=\"de.tsv\", bicameral=True, punctuation=de_punc)\n\n# Add Vocab to WordSiv Object\nws = WordSiv()\nws.add_vocab(\"de-subtitles\", de_vocab)\n\n# Try it out, turning up punctuation randomness so we see more variation\nprint(ws.para(vocab=\"de-subtitles\", rnd_punc=0.5))\n</code></pre></p> <p>Now we see punctuation:</p> <p>Ich ist mit das ich (du und) mit es sie\u2026 Nicht das was zu sie\u2014du die ja nicht und zu ist du? Das er das \u201cwir\u201d ich was sie der du mit das die und zu ich. In und in, ich ja ich die der das (nicht er sie ich) mir.</p>"},{"location":"usage/language-support/#contributing-vocabs-to-wordsiv","title":"Contributing Vocabs to WordSiv","text":"<p>WordSiv is as only as good as the Vocabs (and punctuation dictionaries!) that are available to it, and we'd love any help on improving language support. Feel free to create an issue on the GitHub repo if you're interested in helping us improve language support. You don't even have to be a programmer\u2014we just need native speakers to help us construct useful Vocabs. However, if you are looking to learn some programming, building wordlists and punctuation can be a fun first project (and I'd be glad to help!).</p> <p>My long-term vision is to build a community-maintained project (outside of WordSiv) that has a huge selection of multilingual proofing text, wordlists, punctuation, etc. and resources and code that enable the global type community to more easily leverage the language data that is commonplace in NLP/linguistics/engineering circles. A lot of the source data already exists, it just needs to be adapted for the needs/tooling of type designers.</p> <ol> <li> <p>Licensing for wordlists is a bit odd, because they're often built by crawling a bunch of data with all kinds of licenses. I'm just doing my best here to respect licenses where I can!\u00a0\u21a9</p> </li> <li> <p>I'd recommend deriving punctuation frequencies for the target language from real text, and normalizing the probabilities between 0 and 1. I have a script that builds these dictionaries, which I hope to publish soon!\u00a0\u21a9</p> </li> </ol>"}]}